{"mappings":"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","sources":["node_modules/.pnpm/@parcel+runtime-js@2.8.1_@parcel+core@2.8.1/node_modules/@parcel/runtime-js/lib/helpers/bundle-manifest.js","node_modules/.pnpm/@parcel+runtime-js@2.8.1_@parcel+core@2.8.1/node_modules/@parcel/runtime-js/lib/runtime-dc20c24c112720dc.js","src/day24/index.js","../js/solutions/24.js","node_modules/.pnpm/@parcel+runtime-js@2.8.1_@parcel+core@2.8.1/node_modules/@parcel/runtime-js/lib/runtime-3d5f761be1530b04.js","node_modules/.pnpm/@parcel+runtime-js@2.8.1_@parcel+core@2.8.1/node_modules/@parcel/runtime-js/lib/runtime-2816e6a9ae788949.js","node_modules/.pnpm/@parcel+runtime-js@2.8.1_@parcel+core@2.8.1/node_modules/@parcel/runtime-js/lib/runtime-972ae5216055aaed.js","node_modules/.pnpm/@parcel+runtime-js@2.8.1_@parcel+core@2.8.1/node_modules/@parcel/runtime-js/lib/runtime-2f5a75ea84a2e8e9.js","node_modules/.pnpm/@parcel+runtime-js@2.8.1_@parcel+core@2.8.1/node_modules/@parcel/runtime-js/lib/runtime-464df1a2920266f6.js","node_modules/.pnpm/@parcel+runtime-js@2.8.1_@parcel+core@2.8.1/node_modules/@parcel/runtime-js/lib/runtime-c0a19c76a38b0d03.js","node_modules/.pnpm/@parcel+runtime-js@2.8.1_@parcel+core@2.8.1/node_modules/@parcel/runtime-js/lib/runtime-48b13e96fe38e7c5.js"],"sourcesContent":["\"use strict\";\n\nvar mapping = {};\n\nfunction register(pairs) {\n  var keys = Object.keys(pairs);\n\n  for (var i = 0; i < keys.length; i++) {\n    mapping[keys[i]] = pairs[keys[i]];\n  }\n}\n\nfunction resolve(id) {\n  var resolved = mapping[id];\n\n  if (resolved == null) {\n    throw new Error('Could not resolve bundle with id ' + id);\n  }\n\n  return resolved;\n}\n\nmodule.exports.register = register;\nmodule.exports.resolve = resolve;","require('./helpers/bundle-manifest').register(JSON.parse(\"{\\\"2xBmn\\\":\\\"index.7b344632.js\\\",\\\"2dmi2\\\":\\\"grass.d15b078f.png\\\",\\\"gGxKH\\\":\\\"wall-v.5e4cbb6f.png\\\",\\\"8i50T\\\":\\\"wall-h.1d5b6cad.png\\\",\\\"iPk1y\\\":\\\"wall-tl.b6d54d5a.png\\\",\\\"a1aok\\\":\\\"wall-tr.757e7329.png\\\",\\\"390yF\\\":\\\"wall-bl.86040f9e.png\\\",\\\"jrZHa\\\":\\\"wall-br.727813ea.png\\\",\\\"iSdbY\\\":\\\"index.64bca685.js\\\"}\"));","import { scaleCanvasToPixelRatio } from \"../common\"\nimport {\n  checks,\n  parseInput,\n  getShortestPath,\n  toArray,\n} from \"../../../js/solutions/24\"\nimport { parseMap2d, Map2d } from \"../../../js/modules/map2d\"\n\nimport grass from \"./img/grass.png\"\nimport wallV from \"./img/wall-v.png\"\nimport wallH from \"./img/wall-h.png\"\nimport wallTL from \"./img/wall-tl.png\"\nimport wallTR from \"./img/wall-tr.png\"\nimport wallBL from \"./img/wall-bl.png\"\nimport wallBR from \"./img/wall-br.png\"\nimport { V } from \"../../../js/modules\"\nimport { it } from \"../../../js/modules/itertools\"\nimport { mod } from \"../../../js/modules/lib\"\n\nconst example = `#.######\n#>>.<^<#\n#.<..<<#\n#>v.><>#\n#<^v^^>#\n######.#`\n\nconst blizzardToChar = {\n  \"<\": \"â‡ \",\n  \">\": \"â‡¢\",\n  \"^\": \"â‡¡\",\n  v: \"â‡£\",\n}\n\nconst canvas = document.getElementById(\"canvas\")\n/** @type {CanvasRenderingContext2D} */\nconst ctx = canvas.getContext(\"2d\")\n\nconst form = document.getElementById(\"input-form\")\nconst inputElement = document.getElementById(\"input\")\ninputElement.value = example\n\nconst controls = document.querySelector(\".controls\")\nconst solveBtn = document.getElementById(\"solve\")\n\nform.addEventListener(\"submit\", function (e) {\n  e.preventDefault()\n  const formData = new FormData(this)\n  const input = formData.get(\"input\")?.toString() ?? \"\"\n  startLevel(input.trim())\n})\n\nconst tileSize = 10\nlet scale = 4\nconst padding = 4\n\nconst colors = {\n  bg: \"#1e130a\",\n  blizzard: \"#4dabf7\",\n}\n\nfunction drawElf(pos) {\n  drawChar(pos, \"ðŸ§Œ\", \"green\", false)\n}\n\nfunction drawElf2(pos) {\n  drawChar(pos, \"ðŸ§â€â™‚ï¸\", \"green\", false)\n}\n\nfunction drawChar(pos, char, color = \"white\", clear = true) {\n  ctx.font = tileSize * scale + \"px monospace\"\n  ctx.textAlign = \"center\"\n  ctx.textBaseline = \"middle\"\n  const size = tileSize * scale\n  if (clear) {\n    ctx.fillStyle = colors.bg\n    ctx.fillRect(pos[0] * size, pos[1] * size, size, size)\n  }\n  ctx.fillStyle = color\n  ctx.fillText(char, pos[0] * size + size / 2, pos[1] * size + size / 2)\n}\n\nfunction drawSprite(pos, sprite) {\n  ctx.imageSmoothingEnabled = false\n  ctx.drawImage(\n    sprite,\n    0,\n    0,\n    tileSize,\n    tileSize,\n    pos[0] * tileSize * scale,\n    pos[1] * tileSize * scale,\n    tileSize * scale,\n    tileSize * scale,\n  )\n}\n\nfunction loadSprite(path) {\n  return new Promise((resolve, reject) => {\n    const img = new Image()\n    img.onload = () => resolve(img)\n    img.onerror = reject\n    img.src = path\n  })\n}\n\nasync function loadSprites() {\n  const sprites = await Promise.all([\n    loadSprite(grass),\n    loadSprite(wallV),\n    loadSprite(wallH),\n    loadSprite(wallTL),\n    loadSprite(wallTR),\n    loadSprite(wallBL),\n    loadSprite(wallBR),\n  ])\n  return {\n    grass: sprites[0],\n    wallV: sprites[1],\n    wallH: sprites[2],\n    wallTL: sprites[3],\n    wallTR: sprites[4],\n    wallBL: sprites[5],\n    wallBR: sprites[6],\n  }\n}\n\nfunction delay(ms) {\n  return new Promise((resolve) => setTimeout(resolve, ms))\n}\n\nlet handle = 0\n\nasync function startLevel(level) {\n  const map = parseInput(level)\n  const width = (map.width + 2) * tileSize + padding * 2\n  const height = (map.height + 2) * tileSize + padding * 2\n  const blizzards = it(map)\n    .filter((x) => x.value !== \".\")\n    .toArray()\n\n  const screenWidth = window.innerWidth\n  const maxScale = Math.max(Math.min(Math.floor(screenWidth / width), 4), 1)\n\n  scale = maxScale\n\n  scaleCanvasToPixelRatio(ctx, width, height, scale)\n  ctx.fillStyle = colors.bg\n  ctx.fillRect(0, 0, canvas.width, canvas.height)\n\n  ctx.translate(padding * scale, padding * scale)\n\n  const message = \"Loading...\"\n  let timePassed = Date.now()\n  for (let i = 0; i < message.length; i++) {\n    drawChar([i, 1], message[i], \"white\")\n  }\n  const sprites = await loadSprites()\n  const shortestPath = toArray(\n    getShortestPath(map, [0, -1], [map.width - 1, map.height], 0),\n  )\n  timePassed = Date.now() - timePassed\n  if (timePassed < 1000) {\n    await delay(1000 - timePassed)\n  }\n\n  ctx.fillStyle = colors.bg\n  ctx.fillRect(-padding, -padding, canvas.width, canvas.height)\n\n  let playerPos = [0, -1]\n  let time = 0\n  let lost = false\n  let won = false\n  let blizzardsToDraw = blizzards\n\n  drawLevel(map, time)\n  setButtonsState()\n\n  async function showSolution() {\n    cancelAnimationFrame(handle)\n    blockAllButtons()\n\n    for (const [pos] of shortestPath) {\n      await movePlayerFromToWithAnimation(playerPos, pos, 100)\n    }\n  }\n\n  function movePlayerFromToWithAnimation(from, to, duration) {\n    return new Promise((res) => {\n      const [x1, y1] = from\n      const [x2, y2] = to\n      const dx = x2 - x1\n      const dy = y2 - y1\n      let lastTime = 0\n\n      const origPoses = blizzardsToDraw.map((b) => b.pos)\n\n      function loop(dt) {\n        if (lastTime === 0) {\n          lastTime = dt\n        }\n        const dTime = dt - lastTime\n        const progress = Math.min(dTime / duration, 1)\n        const x = x1 + dx * progress\n        const y = y1 + dy * progress\n        playerPos = [x, y]\n\n        blizzardsToDraw.forEach((b, i) => {\n          const dx = b.value === \"<\" ? -1 : b.value === \">\" ? 1 : 0\n          const dy = b.value === \"^\" ? -1 : b.value === \"v\" ? 1 : 0\n          blizzardsToDraw[i] = {\n            value: b.value,\n            pos: [\n              origPoses[i][0] + dx * progress,\n              origPoses[i][1] + dy * progress,\n            ],\n          }\n        })\n\n        drawLevel(map, time)\n        if (progress < 1) {\n          handle = requestAnimationFrame(loop)\n        } else {\n          cancelAnimationFrame(handle)\n          playerPos = to\n          time++\n          blizzardsToDraw.forEach((b, i) => {\n            const dx = b.value === \"<\" ? -1 : b.value === \">\" ? 1 : 0\n            const dy = b.value === \"^\" ? -1 : b.value === \"v\" ? 1 : 0\n            const x = mod(origPoses[i][0] + dx, map.width)\n            const y = mod(origPoses[i][1] + dy, map.height)\n\n            blizzardsToDraw[i] = {\n              value: b.value,\n              pos: [x, y],\n            }\n          })\n          drawLevel(map, time)\n          res()\n        }\n      }\n      loop(0)\n    })\n  }\n\n  function drawLevel(map, time) {\n    ctx.fillStyle = colors.bg\n    ctx.fillRect(\n      -padding * scale,\n      -padding * scale,\n      canvas.width,\n      canvas.height,\n    )\n\n    let drawMap = new Map2d()\n    for (let i = -1; i <= map.width; i++) {\n      drawMap.set([i, -1], \"#\")\n      drawMap.set([i, map.height], \"#\")\n    }\n    for (let i = 0; i < map.height; i++) {\n      drawMap.set([-1, i], \"#\")\n      drawMap.set([map.width, i], \"#\")\n    }\n    drawMap.set([0, -1], \".\")\n    drawMap.set([map.width - 1, map.height], \".\")\n    drawMap = parseMap2d(drawMap.toString())\n\n    for (const { pos, value } of drawMap) {\n      if (value === \"#\") {\n        const isWallOnLeft = drawMap.get([pos[0] - 1, pos[1]]) === \"#\"\n        const isWallOnRight = drawMap.get([pos[0] + 1, pos[1]]) === \"#\"\n        const isWallOnTop = drawMap.get([pos[0], pos[1] - 1]) === \"#\"\n        const isWallOnBottom = drawMap.get([pos[0], pos[1] + 1]) === \"#\"\n\n        if (isWallOnRight && isWallOnBottom) {\n          drawSprite(pos, sprites.wallTL)\n        } else if (\n          (isWallOnLeft && isWallOnBottom) ||\n          (isWallOnLeft && !isWallOnRight)\n        ) {\n          drawSprite(pos, sprites.wallTR)\n        } else if (\n          (isWallOnRight && isWallOnTop) ||\n          (isWallOnRight && !isWallOnLeft)\n        ) {\n          drawSprite(pos, sprites.wallBL)\n        } else if (isWallOnLeft && isWallOnTop) {\n          drawSprite(pos, sprites.wallBR)\n        } else if (isWallOnRight || isWallOnLeft) {\n          drawSprite(pos, sprites.wallH)\n        } else {\n          drawSprite(pos, sprites.wallV)\n        }\n      } else {\n        // drawSprite(pos, sprites.grass)\n      }\n    }\n\n    blizzardsToDraw.forEach((blizzard) => {\n      drawChar(\n        V.add(blizzard.pos, V.vec(1, 1)),\n        blizzardToChar[blizzard.value],\n        colors.blizzard,\n        false,\n      )\n    })\n\n    drawElf([playerPos[0] + 1, playerPos[1] + 1])\n    drawElf2([drawMap.width - 2, drawMap.height - 1])\n  }\n\n  function blockAllButtons() {\n    for (const button of controls.children) {\n      button.disabled = true\n    }\n  }\n\n  function setButtonsState() {\n    const canMove = {\n      up:\n        V.eq([playerPos[0], playerPos[1] - 1], [0, -1]) ||\n        map.has([playerPos[0], playerPos[1] - 1]),\n      down:\n        V.eq([playerPos[0], playerPos[1] + 1], [map.width - 1, map.height]) ||\n        map.has([playerPos[0], playerPos[1] + 1]),\n      left: map.has([playerPos[0] - 1, playerPos[1]]),\n      right: map.has([playerPos[0] + 1, playerPos[1]]),\n      stay: true,\n    }\n    for (const button of controls.children) {\n      button.disabled = lost || won || !canMove[button.name]\n    }\n  }\n\n  function drawLoseScreen() {\n    ctx.fillStyle = colors.bg\n    ctx.fillRect(0, 0, canvas.width, canvas.height)\n    const message = \"You lost!\"\n    for (let i = 0; i < message.length; i++) {\n      drawChar([i, 1], message[i], \"red\")\n    }\n  }\n\n  function drawWinScreen() {\n    ctx.fillStyle = colors.bg\n    ctx.fillRect(0, 0, canvas.width, canvas.height)\n    const message = \"You won!\"\n    for (let i = 0; i < message.length; i++) {\n      drawChar([i, 1], message[i], \"green\")\n    }\n  }\n\n  function checkWinLose() {\n    if (V.eq(playerPos, [map.width - 1, map.height])) {\n      won = true\n      drawWinScreen()\n    } else if (\n      checks.u(map, playerPos, time) ||\n      checks.d(map, playerPos, time) ||\n      checks.l(map, playerPos, time) ||\n      checks.r(map, playerPos, time)\n    ) {\n      lost = true\n      drawLoseScreen()\n    }\n  }\n\n  async function handleMove(direction) {\n    let nextPos = [...playerPos]\n    if (direction === \"up\") {\n      nextPos[1]--\n    } else if (direction === \"down\") {\n      nextPos[1]++\n    } else if (direction === \"left\") {\n      nextPos[0]--\n    } else if (direction === \"right\") {\n      nextPos[0]++\n    }\n    await movePlayerFromToWithAnimation(playerPos, nextPos, 300)\n    checkWinLose()\n    setButtonsState()\n  }\n\n  controls.onclick = function (e) {\n    handleMove(e.target.name)\n  }\n\n  solveBtn.onclick = function () {\n    showSolution()\n  }\n}\n","// @ts-check\n\nimport { V } from \"../modules/index.js\"\nimport { mod, readLines } from \"../modules/lib.js\"\nimport { Map2d, parseMap2d } from \"../modules/map2d.js\"\n\nexport const useExample = false\n\nexport const exampleInput = `\\\n#.######\n#>>.<^<#\n#.<..<<#\n#>v.><>#\n#<^v^^>#\n######.#`\n\n/** @typedef {ReturnType<typeof parseInput>} InputType */\n\nexport const parseInput = (/** @type {string} */ input) => {\n  /** @type {Map2d<string>} */\n  const resultMap = new Map2d()\n  const lines = readLines(input)\n  for (let y = 1; y < lines.length - 1; y++) {\n    for (let x = 1; x < lines[y].length - 1; x++) {\n      resultMap.set(V.vec(x - 1, y - 1), lines[y][x])\n    }\n  }\n  return resultMap\n}\n\n/**\n *\n * @param {Map2d<string>} map\n * @param {V.Vec2} pos\n * @param {number} time\n * @returns\n */\nfunction isBlizzard(map, pos, time) {\n  return (\n    checks.u(map, pos, time) ||\n    checks.d(map, pos, time) ||\n    checks.l(map, pos, time) ||\n    checks.r(map, pos, time)\n  )\n}\n\n/** @type {Record<\"u\" | \"d\" | \"l\" |\"r\", (map: Map2d<string>, pos: V.Vec2, time: number) => boolean>} */\nexport const checks = {\n  u: (map, [x, y], time) => map.get([x, mod(y + time, map.height)]) === \"^\",\n  d: (map, [x, y], time) => map.get([x, mod(y - time, map.height)]) === \"v\",\n  l: (map, [x, y], time) => map.get([mod(x + time, map.width), y]) === \"<\",\n  r: (map, [x, y], time) => map.get([mod(x - time, map.width), y]) === \">\",\n}\n\n/**\n *\n * @param {Map2d<string>} map\n * @param {V.Vec2 | null} me\n * @param {number} time\n */\nexport function prepareMapForDraw(map, me, time) {\n  const drawMap = new Map2d()\n\n  for (const { pos } of map) {\n    const blizzards = []\n    if (checks.u(map, pos, time)) blizzards.push(\"^\")\n    if (checks.d(map, pos, time)) blizzards.push(\"v\")\n    if (checks.l(map, pos, time)) blizzards.push(\"<\")\n    if (checks.r(map, pos, time)) blizzards.push(\">\")\n    if (blizzards.length > 0) {\n      drawMap.set(pos, blizzards.length === 1 ? blizzards[0] : blizzards.length)\n    }\n  }\n  for (let i = -1; i <= map.width; i++) {\n    drawMap.set([i, -1], \"#\")\n    drawMap.set([i, map.height], \"#\")\n  }\n  for (let i = 0; i < map.height; i++) {\n    drawMap.set([-1, i], \"#\")\n    drawMap.set([map.width, i], \"#\")\n  }\n  drawMap.set([0, -1], \".\")\n  drawMap.set([map.width - 1, map.height], \".\")\n  if (me) drawMap.set(me, \"E\")\n  return parseMap2d(drawMap.toString())\n}\n\n/** @typedef {[V.Vec2, number, BfsStep | null]} BfsStep */\n\n/**\n * @param {BfsStep} step\n */\nexport function toArray(step) {\n  const result = []\n  while (step) {\n    result.push(step)\n    step = step[2]\n  }\n  return result.reverse()\n}\n\n/**\n * @param {Map2d<string>} map\n * @param {V.Vec2} start\n * @param {V.Vec2} end\n * @param {V.Vec2} pos\n * @param {number} t\n * @returns {V.Vec2[]}\n */\nexport function getAvailablePositions(map, start, end, pos, t) {\n  return [...V.DIRS_4, V.ZERO]\n    .map((d) => V.add(pos, d))\n    .filter((n) => {\n      return (\n        !isBlizzard(map, n, t + 1) &&\n        (V.eq(n, start) || V.eq(n, end) || map.has(n))\n      )\n    })\n}\n\n/**\n *\n * @param {InputType} map\n * @param {V.Vec2} start\n * @param {V.Vec2} end\n * @param {number} startTime\n * @returns\n */\nexport function getShortestPath(map, start, end, startTime) {\n  while (isBlizzard(map, start, startTime)) startTime++\n\n  /**\n   * @param {V.Vec2} start\n   * @param {V.Vec2} end\n   * @param {number} startTime\n   *\n   * @returns {BfsStep | null}\n   */\n  function bfs(start, end, startTime) {\n    /** @type {Array<BfsStep>} */\n    const queue = [[start, startTime, null]]\n    const visited = new Set()\n\n    while (queue.length > 0) {\n      const cur = queue.shift()\n      const [pos, t] = cur\n      if (V.eq(pos, end)) return cur\n\n      const key = pos.toString() + \":\" + t\n      if (visited.has(key)) continue\n      else visited.add(key)\n\n      for (const next of getAvailablePositions(map, start, end, pos, t)) {\n        queue.push([next, t + 1, cur])\n      }\n    }\n\n    throw new Error(\"No path found\")\n  }\n\n  const result = bfs(start, end, startTime)\n  // toArray(result).forEach((pos, i) => {\n  //   drawMap(map, pos[0], i + startTime)\n  // })\n  return result\n}\n\n/**\n * @param {InputType} input\n */\nexport function part1(input) {\n  const start = V.vec(0, -1)\n  const end = V.vec(input.width - 1, input.height)\n  return getShortestPath(input, start, end, 0)[1]\n}\n\n/**\n * @param {InputType} input\n */\nexport function part2(input) {\n  const start = V.vec(0, -1)\n  const end = V.vec(input.width - 1, input.height)\n  const first = getShortestPath(input, start, end, 0)\n  const second = getShortestPath(input, end, start, first[1])\n  const third = getShortestPath(input, start, end, second[1])\n  return third\n}\n","module.exports = new __parcel__URL__(\"../\" + require('./helpers/bundle-manifest').resolve(\"2dmi2\")).toString();","module.exports = new __parcel__URL__(\"../\" + require('./helpers/bundle-manifest').resolve(\"gGxKH\")).toString();","module.exports = new __parcel__URL__(\"../\" + require('./helpers/bundle-manifest').resolve(\"8i50T\")).toString();","module.exports = new __parcel__URL__(\"../\" + require('./helpers/bundle-manifest').resolve(\"iPk1y\")).toString();","module.exports = new __parcel__URL__(\"../\" + require('./helpers/bundle-manifest').resolve(\"a1aok\")).toString();","module.exports = new __parcel__URL__(\"../\" + require('./helpers/bundle-manifest').resolve(\"390yF\")).toString();","module.exports = new __parcel__URL__(\"../\" + require('./helpers/bundle-manifest').resolve(\"jrZHa\")).toString();"],"names":["$3ece94fe9f768145$export$6503ec6e8aabbaf","$3ece94fe9f768145$export$f7ad0328861e2f03","$3ece94fe9f768145$var$mapping","pairs","keys","Object","i","length","id","resolved","Error","parcelRequire","register","JSON","parse","$7zFg5","$idVGl","$30e6b530f34a47e9$export$20bebb8aee8dd3f5","input","resultMap","$jOfNW","Map2d","lines","$1CMLe","readLines","y","x","set","V","vec","$30e6b530f34a47e9$var$isBlizzard","map","pos","time","$30e6b530f34a47e9$export$ea3f7679f8e99d0","u","d","l","r","get","mod","height","width","$30e6b530f34a47e9$export$45b10814cc054894","step","result","push","reverse","$30e6b530f34a47e9$export$264362ef2038ecd8","start","end","t","DIRS_4","ZERO","add","filter","n","eq","has","$30e6b530f34a47e9$export$991f991c113b9b98","startTime","queue","visited","Set","cur","shift","key","toString","next","bfs","$af65021eb08c64c4$exports","URL","resolve","import","meta","url","$0153c87d3ae7b077$exports","$6261212292e3080c$exports","$6c915fbb4084faeb$exports","$fbaff03458da4e2b$exports","$289a05e3543c1325$exports","$3bb6f8d7a0ccdda0$exports","$2a7a04ce5b23d3b8$var$blizzardToChar","v","$2a7a04ce5b23d3b8$var$canvas","document","getElementById","$2a7a04ce5b23d3b8$var$ctx","getContext","$2a7a04ce5b23d3b8$var$form","value","$2a7a04ce5b23d3b8$var$controls","querySelector","$2a7a04ce5b23d3b8$var$solveBtn","addEventListener","e","preventDefault","async","level","$2a7a04ce5b23d3b8$var$tileSize","$2a7a04ce5b23d3b8$var$padding","blizzards","$c04jy","it","toArray","screenWidth","window","innerWidth","maxScale","Math","max","min","floor","$2a7a04ce5b23d3b8$var$scale","scaleCanvasToPixelRatio","fillStyle","$2a7a04ce5b23d3b8$var$colors","fillRect","translate","message","timePassed","Date","now","$2a7a04ce5b23d3b8$var$drawChar","sprites","Promise","all","$2a7a04ce5b23d3b8$var$loadSprite","$parcel$interopDefault","grass","wallV","wallH","wallTL","wallTR","wallBL","wallBR","$2a7a04ce5b23d3b8$var$loadSprites","shortestPath","ms","setTimeout","playerPos","lost","won","blizzardsToDraw","showSolution","cancelAnimationFrame","$2a7a04ce5b23d3b8$var$handle","blockAllButtons","movePlayerFromToWithAnimation","from","to","duration","res","x1","y1","x2","y2","dx","dy","lastTime","origPoses","b","loop","dt","dTime","progress","forEach","drawLevel","requestAnimationFrame","drawMap","i1","parseMap2d","isWallOnLeft","isWallOnRight","isWallOnTop","isWallOnBottom","$2a7a04ce5b23d3b8$var$drawSprite","blizzard","$2a7a04ce5b23d3b8$var$drawElf2","button","children","disabled","setButtonsState","canMove","up","down","left","right","stay","name","drawLoseScreen","drawWinScreen","checkWinLose","handleMove","direction","nextPos","onclick","target","$2a7a04ce5b23d3b8$var$startLevel","FormData","this","trim","char","color","clear","font","textAlign","textBaseline","size","fillText","sprite","imageSmoothingEnabled","drawImage","path","reject","img","Image","onload","onerror","src"],"version":3,"file":"index.7b344632.js.map"}