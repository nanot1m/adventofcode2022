{"mappings":"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","sources":["../js/modules/index.js","../js/modules/vec.js","../js/modules/lib.js","../js/modules/itertools.js","../js/modules/priority-queue.js","../js/modules/map2d.js"],"sourcesContent":["// @ts-check\n\nexport * as V from \"./vec.js\"\nexport * as Lib from \"./lib.js\"\nexport * as Itertools from \"./itertools.js\"\nexport { PriorityQueue } from \"./priority-queue.js\"\n","// @ts-check\n\n/**\n * @typedef {[x: number, y: number]} Vec2\n */\n\n/**\n * @typedef {\"U\" | \"R\"| \"D\" | \"L\" | \"UR\" | \"UL\"} Dir\n */\n\n/** @type {Record<Dir, Vec2>} */\nexport const DIR_TO_VEC = {\n  U: [0, 1],\n  R: [1, 0],\n  D: [0, -1],\n  L: [-1, 0],\n  UR: [1, 1],\n  UL: [-1, 1],\n}\n\nexport const DIRS_4 = [DIR_TO_VEC.U, DIR_TO_VEC.R, DIR_TO_VEC.D, DIR_TO_VEC.L]\nexport const DIRS_3_TOP = [DIR_TO_VEC.UL, DIR_TO_VEC.U, DIR_TO_VEC.UR]\n\n/**\n *\n * @param {string} dir\n * @returns {Dir}\n */\nexport const asDir = (dir) => {\n  if (dir in DIR_TO_VEC) {\n    return /** @type {Dir} */ (dir)\n  }\n\n  throw new Error(`Invalid direction: ${dir}`)\n}\n\n/**\n *\n * @param {Vec2} vec\n * @returns {Vec2}\n */\nexport const signed = ([x, y]) => [Math.sign(x), Math.sign(y)]\n\n/**\n *\n * @param {Vec2} vecA\n * @param {Vec2} vecB\n * @returns {Vec2}\n */\nexport const add = ([x1, y1], [x2, y2]) => [x1 + x2, y1 + y2]\n\n/**\n *\n * @param {Vec2} vecA\n * @param {Vec2} vecB\n * @returns {Vec2}\n */\nexport const sub = ([x1, y1], [x2, y2]) => [x1 - x2, y1 - y2]\n\n/**\n * @param {Dir} dir\n * @returns {Vec2}\n */\nexport const fromDir = (dir) => DIR_TO_VEC[dir]\n\n/**\n * @returns {Vec2}\n */\nexport const zero = () => [0, 0]\n\n/**\n * @param {number} x\n * @param {number} y\n * @returns {Vec2}\n */\nexport const vec = (x, y) => [x, y]\n\n/**\n * @param {Vec2} vec\n */\nexport const x = (vec) => vec[0]\n\n/**\n * @param {Vec2} vec\n */\nexport const y = (vec) => vec[1]\n\n/**\n * @param {unknown} arg\n * @returns {arg is Vec2}\n */\nexport const isVec = (arg) =>\n  Array.isArray(arg) &&\n  arg.length === 2 &&\n  typeof arg[0] === \"number\" &&\n  typeof arg[1] === \"number\"\n\n/**\n * @param {Vec2} vecA\n * @param {Vec2} vecB\n * @returns {boolean}\n */\nexport const eq = (vecA, vecB) => vecA[0] === vecB[0] && vecA[1] === vecB[1]\n\n/**\n * @param {Vec2} vecA\n * @param {Vec2} vecB\n * @returns {Vec2}\n */\nexport const min = (vecA, vecB) => [\n  Math.min(vecA[0], vecB[0]),\n  Math.min(vecA[1], vecB[1]),\n]\n\n/**\n * @param {Vec2} vecA\n * @param {Vec2} vecB\n * @returns {Vec2}\n */\nexport const max = (vecA, vecB) => [\n  Math.max(vecA[0], vecB[0]),\n  Math.max(vecA[1], vecB[1]),\n]\n\n/**\n * @param {Vec2} start\n * @param {Vec2} end\n */\nexport function* segment(start, end) {\n  const delta = sub(end, start)\n  const dir = signed(delta)\n  const steps = cLen(start, end)\n\n  let pos = start\n  yield pos\n  for (let i = 0; i < steps; i++) {\n    pos = add(pos, dir)\n    yield pos\n  }\n}\n\n/**\n * @type {Vec2}\n */\nexport const ZERO = zero()\n\n/**\n *\n * @param {Vec2} vecA\n * @param {Vec2} vecB\n * @returns {number}\n */\nexport const cLen = (vecA, vecB = zero()) =>\n  Math.max(Math.abs(vecA[0] - vecB[0]), Math.abs(vecA[1] - vecB[1]))\n","// @ts-check\n\nimport { V } from \"./index.js\"\nimport { it } from \"./itertools.js\"\n\n/**\n * @param {T} x\n * @returns {T}\n * @template T\n */\nexport function id(x) {\n  return x\n}\n\n/**\n * @param {T[]} xs\n * @param {(arg: T) => string | number} fn\n *\n * @template T\n */\nexport function minBy(xs, fn) {\n  return xs.reduce((a, b) => (fn(a) < fn(b) ? a : b))\n}\n\n/**\n * @param {T[]} xs\n * @param {(arg: T) => string | number} fn\n *\n * @template T\n */\nexport function maxBy(xs, fn) {\n  return xs.reduce((a, b) => (fn(a) > fn(b) ? a : b))\n}\n\n/**\n * @param {number[]} xs\n */\nexport function min(xs) {\n  return minBy(xs, id)\n}\n\n/**\n * @param {number[]} xs\n */\nexport function max(xs) {\n  return maxBy(xs, id)\n}\n\n/**\n *\n * @param {T[]} xs\n * @param {T[][]} yss\n * @returns {T[][]}\n *\n * @template T\n */\nexport function zip(xs, ...yss) {\n  const minLength = minBy(yss, (ys) => ys.length).length\n  return xs.slice(0, minLength).map((val, i) =>\n    yss.reduce(\n      (a, arr) => {\n        a.push(arr[i])\n        return a\n      },\n      [val],\n    ),\n  )\n}\n\n/**\n * @param {string} input\n */\nexport function readLines(input) {\n  return input.split(\"\\n\")\n}\n\n/**\n * @param {string} input\n */\nexport function readBlocks(input) {\n  return input.split(\"\\n\\n\")\n}\n\n/**\n * @param {string} input\n * @returns\n */\nexport function readIntLines(input) {\n  return readLines(input).map(Number)\n}\n\n/**\n * @param {string} input\n * @param {string} [separator]\n */\nexport function readIntArr(input, separator = \",\") {\n  return input.split(separator).map(Number)\n}\n\n/**\n *\n * @param {T} value\n * @template T\n */\nexport function functor(value) {\n  return {\n    /**\n     *\n     * @param {(arg: T) => R} fn\n     * @template R\n     */\n    map(fn) {\n      return functor(fn(value))\n    },\n    get() {\n      return value\n    },\n  }\n}\n\n/**\n * @param {T[]} xs\n * @param {number} n\n * @template T\n */\nexport function cycle(xs, n) {\n  return xs.slice(n).concat(xs.slice(0, n))\n}\n\n/**\n * @param {T[]} xs\n * @param {number} n\n * @template T\n */\nexport function at(xs, n) {\n  if (n < 0) {\n    n = xs.length + n\n  }\n  return xs[n]\n}\n\n/**\n * @param {number} a\n * @param {number} b\n * @returns\n */\nexport function add(a, b) {\n  return a + b\n}\n\n/**\n * @param {number} a\n * @param {number} b\n * @returns\n */\nexport function mul(a, b) {\n  return a * b\n}\n\n/**\n * @param {number} a\n * @param {number} b\n * @returns\n */\nexport function compareAsc(a, b) {\n  return a - b\n}\n\n/**\n * @param {number} a\n * @param {number} b\n * @returns\n */\nexport function compareDesc(a, b) {\n  return b - a\n}\n\n/**\n *\n * @param {T[]} xs\n * @param {number} i\n * @param {(arg: T) => T} fn\n *\n * @template T\n */\nexport function update(xs, i, fn) {\n  return xs\n    .slice(0, i)\n    .concat(fn(xs[i]))\n    .concat(xs.slice(i + 1))\n}\n\n/**\n * @param {number} x\n */\nexport function inc(x) {\n  return x + 1\n}\n\n/**\n * @param {T} xs\n * @param {number} n\n * @returns {[T, T]}\n *\n * @template {{slice(start: number, end?: number): T}} T\n */\nexport function splitAt(xs, n) {\n  return [xs.slice(0, n), xs.slice(n)]\n}\n\n/**\n *\n * @param {T[][]} arr\n * @param {boolean} clockwise\n * @returns {T[][]}\n *\n * @template T\n */\nexport function rotate2d(arr, clockwise = true) {\n  const height = arr.length\n  const width = it(arr)\n    .map((line) => line.length)\n    .max()\n\n  const rotated = Array.from({ length: width }, () =>\n    Array.from({ length: height }),\n  )\n\n  for (let y = 0; y < height; y++) {\n    for (let x = 0; x < width; x++) {\n      const value = arr[y]?.[x]\n      const [i, j] = clockwise ? [x, height - y - 1] : [width - x - 1, y]\n      rotated[i][j] = value\n    }\n  }\n\n  return rotated\n}\n\n/**\n *\n * @param {string[]} strings\n * @param {boolean} clockwise\n */\nexport function rotateStrings2d(strings, clockwise = true) {\n  const rotated = rotate2d(\n    strings.map((str) => str.split(\"\")),\n    clockwise,\n  )\n\n  return rotated.map((line) =>\n    line\n      .map((x) => x ?? \" \")\n      .join(\"\")\n      .trimEnd(),\n  )\n}\n\n/**\n *\n * @param {string} str\n * @param {boolean} [clockwise]\n *\n * @returns {string}\n */\nexport function rotateString2d(str, clockwise = true) {\n  return rotateStrings2d(str.split(\"\\n\"), clockwise).join(\"\\n\")\n}\n\n/**\n *\n * @param  {T} args\n * @returns {T}\n *\n * @template {unknown[]} T\n */\nexport function tuple(...args) {\n  return args\n}\n\n/**\n * @type {import(\"./types.js\").RotateFn}\n *\n * @template T\n */\n// @ts-ignore\nexport const rotate = (\n  /** @type {string | string[] | T[][]} */ rotatable,\n  clockwise = true,\n) => {\n  if (typeof rotatable === \"string\") {\n    return rotateString2d(rotatable, clockwise)\n  }\n  if (typeof rotatable[0] === \"string\") {\n    return rotateStrings2d(/** @type {string[]} */ (rotatable), clockwise)\n  }\n  return rotate2d(/** @type {T[][]} */ (rotatable), clockwise)\n}\n\n/**\n * @param {string} strVal\n */\nfunction tryGetSeparator(strVal) {\n  const separators = [\" -> \", \", \", \",\", \" - \", \"-\", \" \"]\n  for (const separator of separators) {\n    if (strVal.includes(separator)) {\n      return separator\n    }\n  }\n  return null\n}\n\n/**\n * @param {string} strVal\n * @param {string} type\n *\n * @returns {unknown}\n */\nfunction strToType(strVal, type) {\n  if (!type) {\n    return strVal\n  }\n  if (type === \"vec\") {\n    const [x, y] = strVal.split(\",\").map(Number)\n    return V.vec(x, y)\n  }\n  if (type === \"int\") {\n    return parseInt(strVal, 10)\n  }\n  if (type.endsWith(\"[]\")) {\n    const separator = tryGetSeparator(strVal)\n    if (!separator) {\n      return [strToType(strVal, type.slice(0, -2))]\n    }\n    const childType = type.slice(0, -2)\n    return strVal.split(separator).map((x) => strToType(x, childType))\n  }\n  return strVal\n}\n\n/**\n * @param {T} type\n * @returns {(strVal: string) => import(\"./types.js\").TemplateValueReturnType<T>}\n *\n * @template {string} T\n */\nexport function typed(type) {\n  return (strVal) =>\n    /** @type {import(\"./types.js\").TemplateValueReturnType<T>} */ (\n      strToType(strVal, type)\n    )\n}\n\n/**\n * @param {TemplateStringsArray} strings\n * @param  {T} keys\n *\n * @template {string[]} T\n */\nexport function tpl(strings, ...keys) {\n  /**\n   * @param {string} input\n   * @returns {{[P in T[number] as import(\"./types.js\").TemplateKey<P>]: import(\"./types.js\").TemplateValue<P> }}\n   */\n  function parse(input) {\n    /** @type {Record<string, any>} */\n    const model = {}\n    let lastIndex = 0\n    for (let i = 0; i < keys.length; i++) {\n      const start = strings[i].length + lastIndex\n      const end = strings[i + 1]\n        ? input.indexOf(strings[i + 1], start)\n        : input.length\n      const strVal = input.slice(start, end)\n      const [key, type] = keys[i].split(\"|\")\n      model[key] = strToType(strVal, type)\n      lastIndex = end\n    }\n    return /** @type {any} */ (model)\n  }\n\n  /**\n   * @param {(arg: ReturnType<typeof parse>) => R} fn\n   * @template R\n   */\n  parse.map = (fn) => (/** @type {string} */ input) => fn(parse(input))\n\n  return parse\n}\n","// @ts-check\n\nimport { add } from \"./lib.js\"\nimport * as V from \"./vec.js\"\n\n/**\n * @param {number} [start]\n * @param {number} [end]\n * @param {number} [step]\n */\nexport function* range(start, end, step = 1) {\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = start\n    start = 0\n  }\n  if (step === undefined) {\n    step = 1\n  }\n  for (let i = start; i < end; i += step) {\n    yield i\n  }\n}\n\n/**\n * @param {Iterable<T>} iterable\n * @param {number} n\n *\n * @template T\n */\nexport function* skip(iterable, n) {\n  for (const x of iterable) {\n    if (n === 0) {\n      yield x\n    } else {\n      n -= 1\n    }\n  }\n}\n\n/**\n * @param {Iterable<T>} iterable\n * @param {number} n\n *\n * @template T\n */\nexport function* take(iterable, n) {\n  for (const x of iterable) {\n    if (n === 0) {\n      return\n    }\n    yield x\n    n -= 1\n  }\n}\n\n/**\n * @param {Iterable<T>} iterable\n *\n * @template T\n */\nexport function first(iterable) {\n  for (const x of iterable) {\n    return x\n  }\n}\n\n/**\n * @param {Iterable<T>} iterable\n *\n * @template T\n */\nexport function last(iterable) {\n  let last\n  for (const x of iterable) {\n    last = x\n  }\n  return last\n}\n\n/**\n * @param {Iterable<T>} iterable\n * @param {(arg0: R, arg1: T, index: number) => R} reducer\n * @param {R} initial\n *\n * @template T\n * @template R\n */\nexport function reduce(iterable, reducer, initial) {\n  let acc = initial\n  let idx = 0\n  for (const x of iterable) {\n    acc = reducer(acc, x, idx++)\n  }\n  return acc\n}\n\n/**\n *\n * @param {T} x\n * @param {(arg: T) => T} f\n *\n * @template T\n */\nexport function* iterate(x, f) {\n  yield x\n  while (true) {\n    x = f(x)\n    yield x\n  }\n}\n\n/**\n *\n * @param {Iterable<T>} iterable\n * @param {(arg: T) => R} f\n *\n * @template T\n * @template R\n */\nexport function* map(iterable, f) {\n  for (const x of iterable) {\n    yield f(x)\n  }\n}\n\n/**\n *\n * @param {Iterable<T>} iterable\n * @param {number} n\n *\n * @template T\n */\nexport function* groupsOf(iterable, n) {\n  let group = []\n  for (const x of iterable) {\n    group.push(x)\n    if (group.length === n) {\n      yield group\n      group = []\n    }\n  }\n  if (group.length > 0) {\n    yield group\n  }\n}\n\n/**\n * @param {Iterable<T>} iterable\n *\n * @template T\n */\nexport function toArray(iterable) {\n  return Array.from(iterable)\n}\n\n/**\n * @param {Iterable<T>} iterable\n * @param {(value: T) => boolean} predicate\n * @returns {T | undefined}\n * @template T\n */\nexport function find(iterable, predicate) {\n  for (const x of iterable) {\n    if (predicate(x)) {\n      return x\n    }\n  }\n}\n\n/**\n * @param {Iterable<number>} xs\n * @returns\n */\nexport function sum(xs) {\n  return reduce(xs, add, 0)\n}\n\n/**\n * @param {Iterable<T>} iterable\n * @param {(value: T) => boolean} predicate\n * @returns {Iterable<T>}\n * @template T\n */\nexport function* filter(iterable, predicate) {\n  for (const x of iterable) {\n    if (predicate(x)) {\n      yield x\n    }\n  }\n}\n\n/**\n * @param {Iterable<T>} iterable\n * @param {(value: T) => boolean} [predicate]\n * @returns {number}\n * @template T\n */\nexport function count(iterable, predicate = () => true) {\n  let count = 0\n  for (const x of iterable) {\n    if (predicate(x)) {\n      count += 1\n    }\n  }\n  return count\n}\n\n/**\n *\n * @param {Iterable<T>} iterableA\n * @param {Iterable<U>} iterableB\n * @returns {Iterable<[T, U]>}\n *\n * @template T, U\n */\nexport function* zip(iterableA, iterableB) {\n  const iterA = iterableA[Symbol.iterator]()\n  const iterB = iterableB[Symbol.iterator]()\n  while (true) {\n    const { value: a, done: doneA } = iterA.next()\n    const { value: b, done: doneB } = iterB.next()\n    if (doneA || doneB) {\n      return\n    }\n    yield [a, b]\n  }\n}\n\n/**\n *\n * @param {Iterable<T>} iterable\n * @returns {Iterable<[number, T]>}\n *\n * @template T\n */\nexport function indexed(iterable) {\n  return zip(range(Infinity), iterable)\n}\n\n/**\n *\n * @param {Iterable<T>} iterable\n * @param {number} n\n * @returns {Iterable<T[]>}\n *\n * @template T\n */\nexport function* windowed(iterable, n) {\n  const buffer = []\n  for (const x of iterable) {\n    buffer.push(x)\n    if (buffer.length === n) {\n      yield buffer\n      buffer.shift()\n    }\n  }\n}\n\n/**\n * @param {Iterable<T>} iterable\n * @param {(value: T) => boolean} predicate\n * @returns {number}\n * @template T\n */\nexport function findIndex(iterable, predicate) {\n  let i = 0\n  for (const x of iterable) {\n    if (predicate(x)) {\n      return i\n    }\n    i++\n  }\n  return -1\n}\n\n/**\n *\n * @param {Iterable<T>} iterable\n * @param {T} value\n * @returns {number}\n *\n * @template T\n */\nexport function indexOf(iterable, value) {\n  return findIndex(iterable, (x) => x === value)\n}\n\n/**\n *\n * @param {Iterable<T>} iterable\n * @param {(arg: T) => Iterable<R>} f\n * @returns {Iterable<R>}\n *\n * @template T, R\n */\nexport function* flatMap(iterable, f) {\n  for (const x of iterable) {\n    yield* f(x)\n  }\n}\n\n/**\n * @param {Iterable<T>} iterable\n * @param {number} [n]\n * @returns {Iterable<T>}\n *\n * @template T\n */\nexport function* skipLast(iterable, n = 1) {\n  if (n <= 0) {\n    yield* iterable\n    return\n  }\n\n  const buffer = Array(n)\n  let i = 0\n  for (const x of iterable) {\n    if (i >= n) {\n      yield buffer[i % n]\n    }\n    buffer[i % n] = x\n    i++\n  }\n}\n\n/**\n *\n * @param {Iterable<T>} iterable\n * @param {number} every\n * @param {number} [skipInitial]\n * @returns {Iterable<T>}\n *\n * @template T\n */\nexport function* takeEvery(iterable, every, skipInitial = 0) {\n  if (every <= 0) {\n    return\n  }\n  if (skipInitial < 0) {\n    skipInitial = 0\n  }\n\n  for (const x of iterable) {\n    if (skipInitial === 0) {\n      yield x\n      skipInitial = every\n    }\n    skipInitial--\n  }\n}\n\n/**\n * @param {Iterable<T>} iterable\n * @param {(value: T) => boolean} predicate\n * @returns {Iterable<T>}\n * @template T\n */\nexport function* takeWhile(iterable, predicate) {\n  for (const x of iterable) {\n    if (!predicate(x)) {\n      return\n    }\n    yield x\n  }\n}\n\n/**\n * @param {Iterable<T>} iterable\n * @param {(value: T) => boolean} predicate\n * @returns {Iterable<T>}\n * @template T\n */\nexport function* takeUntil(iterable, predicate) {\n  for (const x of iterable) {\n    if (predicate(x)) {\n      return\n    }\n    yield x\n  }\n}\n\n/**\n * @param {Iterable<T>} iterable\n * @param {(value: T) => boolean} predicate\n * @returns {boolean}\n * @template T\n */\nexport function every(iterable, predicate) {\n  for (const x of iterable) {\n    if (!predicate(x)) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n *\n * @param {Iterable<T>} iterable\n * @param {number} index\n * @param {(arg: T) => T} fn\n *\n * @template T\n */\nexport function* updateAt(iterable, index, fn) {\n  let i = 0\n  for (const x of iterable) {\n    if (i === index) {\n      yield fn(x)\n    } else {\n      yield x\n    }\n    i++\n  }\n}\n\n/**\n *\n * @param {Iterable<T>} iterable\n * @param  {T[]} values\n *\n * @template T\n */\nexport function* unshift(iterable, ...values) {\n  yield* values\n  yield* iterable\n}\n\n/**\n * @param {Iterable<T>} iterable\n * @param {(value: T) => boolean} predicate\n * @returns {Iterable<T>}\n * @template T\n */\nexport function* skipAfter(iterable, predicate) {\n  for (const x of iterable) {\n    yield x\n    if (predicate(x)) {\n      return\n    }\n  }\n}\n\n/**\n * @typedef {Iterable<T> & {\n *    map: <R>(fn: (arg: T) => R) => FluentIterable<R>\n *    groupsOf: (n: number) => FluentIterable<T[]>\n *    toArray: () => T[]\n *    first: () => T | undefined\n *    last: () => T | undefined\n *    find: (predicate: (arg: T) => boolean) => T | undefined\n *    skip: (n: number) => FluentIterable<T>\n *    take: (n: number) => FluentIterable<T>\n *    toSet: () => Set<T>\n *    reduce: <R>(reducer: (arg0: R, arg1: T, index: number) => R, init: R) => R\n *    forEach: (fn: (arg: T) => void) => void\n *    count: (predicate?: (arg: T) => boolean) => number\n *    filter: (predicate: (arg: T) => boolean) => FluentIterable<T>\n *    indexed: () => FluentIterable<[number, T]>\n *    windowed: (n: number) => FluentIterable<T[]>\n *    findIndex: (predicate: (arg: T) => boolean) => number\n *    indexOf : (value: T) => number\n *    flatMap: <R>(f: (arg: T) => Iterable<R>) => FluentIterable<R>\n *    skipLast: (n?: number) => FluentIterable<T>\n *    takeEvery: (every: number, skipInitial?: number) => FluentIterable<T>\n *    takeWhile: (predicate: (arg: T) => boolean) => FluentIterable<T>\n *    takeUntil: (predicate: (arg: T) => boolean) => FluentIterable<T>\n *    every: (predicate: (arg: T) => boolean) => boolean\n *    updateAt: (index: number, fn: (arg: T) => T) => FluentIterable<T>\n *    unshift: (...values: T[]) => FluentIterable<T>\n *    skipAfter: (predicate: (arg: T) => boolean) => FluentIterable<T>\n * }} GenericFluentIterable<T>\n *\n *\n * @template T\n */\n\n/**\n * @typedef {GenericFluentIterable<string> & {\n *    join: (separator?: string) => string\n * }} StrFluentIterable\n */\n\n/**\n * @typedef {GenericFluentIterable<number> & {\n *    sum: () => number\n *    min: () => number\n *    max: () => number\n * }} NumFluentIterable\n */\n\n/**\n * @typedef {T extends number\n *    ? NumFluentIterable\n *    : T extends boolean\n *    ? GenericFluentIterable<boolean>\n *    : T extends string\n *    ? StrFluentIterable\n *    : T extends infer U ? GenericFluentIterable<U> : never} FluentIterable\n * @template T\n */\n\n/**\n *\n * @param {Iterable<T>} iterable\n * @returns {FluentIterable<T>}\n * @template T\n */\nexport const it = (iterable) => {\n  /**\n   * @type {FluentIterable<any>}\n   */\n  const returnValue = {\n    //#region GenericFluentIterable methods\n    [Symbol.iterator]: () => iterable[Symbol.iterator](),\n    /** @type {<R>(fn: (arg: T) => R) => FluentIterable<R>} */\n    map: (fn) => it(map(iterable, fn)),\n    groupsOf: (n) => it(groupsOf(iterable, n)),\n    toArray: () => toArray(iterable),\n    first: () => first(iterable),\n    last: () => last(iterable),\n    find: (/** @type {(value: T) => boolean} */ predicate) =>\n      find(iterable, predicate),\n    skip: (n) => it(skip(iterable, n)),\n    take: (n) => it(take(iterable, n)),\n    toSet: () => new Set(iterable),\n    /** @type {<R>(reducer: (arg0: R, arg1: T, index: number) => R, init: R) => R} */\n    reduce: (reducer, initial) => reduce(iterable, reducer, initial),\n    /** @type {(fn: (arg: T) => void) => void} */\n    forEach: (fn) => {\n      for (const x of iterable) {\n        fn(x)\n      }\n    },\n    filter: (/** @type {(arg: T) => boolean} */ predicate) =>\n      it(filter(iterable, predicate)),\n    count: (/** @type {((arg: T) => boolean) | undefined} */ predicate) =>\n      count(iterable, predicate),\n    indexed: () => it(indexed(iterable)),\n    windowed: (n) => it(windowed(iterable, n)),\n    findIndex: (/** @type {(arg: T) => boolean} */ predicate) =>\n      findIndex(iterable, predicate),\n    indexOf: (/** @type {T} */ value) => indexOf(iterable, value),\n    /** @type {<R>(f: (arg: T) => Iterable<R>) => FluentIterable<R>} */\n    flatMap: (f) => it(flatMap(iterable, f)),\n    skipLast: (n) => it(skipLast(iterable, n)),\n    takeEvery: (every, skipInitial) =>\n      it(takeEvery(iterable, every, skipInitial)),\n    takeWhile: (/** @type {(arg: T) => boolean} */ predicate) =>\n      it(takeWhile(iterable, predicate)),\n    takeUntil: (/** @type {(arg: T) => boolean} */ predicate) =>\n      it(takeUntil(iterable, predicate)),\n    every: (/** @type {(arg: T) => boolean} */ predicate) =>\n      every(iterable, predicate),\n    updateAt: (/** @type {number} */ index, /** @type {(arg: T) => T} */ fn) =>\n      it(updateAt(iterable, index, fn)),\n    unshift: (/** @type {T[]} */ ...values) => it(unshift(iterable, ...values)),\n    skipAfter: (/** @type {(arg: T) => boolean} */ predicate) =>\n      it(skipAfter(iterable, predicate)),\n    //#endregion\n\n    //#region NumFluentIterable methods\n    sum: () => sum(/** @type {Iterable<number>} */ (iterable)),\n    min: () =>\n      /** @type {NumFluentIterable} */ (returnValue).reduce(Math.min, Infinity),\n    max: () =>\n      /** @type {NumFluentIterable} */ (returnValue).reduce(\n        Math.max,\n        -Infinity,\n      ),\n    //#endregion\n\n    //#region StrFluentIterable methods\n    join: (separator = \",\") => toArray(iterable).join(separator),\n    //#endregion\n  }\n  return /** @type {FluentIterable<T>} */ (returnValue)\n}\n","// @ts-check\n// https://stackoverflow.com/a/42919752\n\nconst top = 0\nconst parent = (/** @type {number} */ i) => ((i + 1) >>> 1) - 1\nconst left = (/** @type {number} */ i) => (i << 1) + 1\nconst right = (/** @type {number} */ i) => (i + 1) << 1\n\n/**\n * @template T\n * @implements {Iterable<T>}\n */\nexport class PriorityQueue {\n  /**\n   *\n   * @param {(a: T, b: T) => number} comparator\n   */\n  constructor(comparator = (a, b) => Number(a > b)) {\n    /** @type {T[]} @private */\n    this._heap = []\n    /** @private */\n    this._comparator = comparator\n  }\n\n  [Symbol.iterator]() {\n    return {\n      next: () => {\n        if (this.size() > 1) {\n          return { value: this.pop(), done: false }\n        }\n        return { done: true, value: this.pop() }\n      },\n    }\n  }\n\n  size() {\n    return this._heap.length\n  }\n  isEmpty() {\n    return this.size() == 0\n  }\n  peek() {\n    return this._heap[top]\n  }\n  /**\n   * @param  {T[]} values\n   * @returns\n   */\n  push(...values) {\n    values.forEach((value) => {\n      this._heap.push(value)\n      this._siftUp()\n    })\n    return this.size()\n  }\n  pop() {\n    const poppedValue = this.peek()\n    const bottom = this.size() - 1\n    if (bottom > top) {\n      this._swap(top, bottom)\n    }\n    this._heap.pop()\n    this._siftDown()\n    return poppedValue\n  }\n  /**\n   * @param {T} value\n   */\n  replace(value) {\n    const replacedValue = this.peek()\n    this._heap[top] = value\n    this._siftDown()\n    return replacedValue\n  }\n  /**\n   * @param {number} i\n   * @param {number} j\n   * @private\n   */\n  _greater(i, j) {\n    return this._comparator(this._heap[i], this._heap[j]) < 0\n  }\n  /**\n   * @param {number} i\n   * @param {number} j\n   * @private\n   */\n  _swap(i, j) {\n    ;[this._heap[i], this._heap[j]] = [this._heap[j], this._heap[i]]\n  }\n  /**\n   * @private\n   */\n  _siftUp() {\n    let node = this.size() - 1\n    while (node > top && this._greater(node, parent(node))) {\n      this._swap(node, parent(node))\n      node = parent(node)\n    }\n  }\n  /**\n   * @private\n   */\n  _siftDown() {\n    let node = top\n    while (\n      (left(node) < this.size() && this._greater(left(node), node)) ||\n      (right(node) < this.size() && this._greater(right(node), node))\n    ) {\n      let maxChild =\n        right(node) < this.size() && this._greater(right(node), left(node))\n          ? right(node)\n          : left(node)\n      this._swap(node, maxChild)\n      node = maxChild\n    }\n  }\n}\n","// @ts-check\n\nimport { it } from \"./itertools.js\"\nimport * as V from \"./vec.js\"\n\n/**\n * @typedef {Object} BfsPos\n * @property {V.Vec2} pos\n * @property {number} distance\n * @property {T} value\n * @property {BfsPos<T>} [parent]\n *\n * @template T\n */\n\n/**\n *\n * @param {Map2d<T>} map2d\n * @param {(from: BfsPos<T>, to: BfsPos<T>) => boolean} canGoFromTo\n * @param {V.Vec2 | Iterable<V.Vec2>} start\n * @param {(pos: V.Vec2) => Iterable<V.Vec2>} getNeighbors\n *\n * @template T\n */\nexport function* bfs(map2d, canGoFromTo, start, getNeighbors) {\n  /** @type {BfsPos<T>[]} */\n  const queue = []\n\n  if (V.isVec(start)) {\n    queue.push({\n      distance: 0,\n      pos: start,\n      value: map2d.get(start),\n      parent: null,\n    })\n  } else {\n    for (const pos of start) {\n      queue.push({\n        distance: 0,\n        pos: pos,\n        value: map2d.get(pos),\n        parent: null,\n      })\n    }\n  }\n\n  const visited = new Set()\n\n  while (queue.length) {\n    const current = queue.shift()\n    const key = current.pos.join()\n    if (visited.has(key)) continue\n    visited.add(key)\n\n    yield current\n\n    for (const next of getNeighbors(current.pos)) {\n      const nextBfs = {\n        distance: current.distance + 1,\n        pos: next,\n        value: map2d.get(next),\n        parent: current,\n      }\n\n      if (canGoFromTo(current, nextBfs)) {\n        queue.push(nextBfs)\n      }\n    }\n  }\n}\n\n/**\n * @implements {Iterable<{pos: V.Vec2;value: T;}>}\n * @template T\n */\nexport class Map2d {\n  /**\n   * @param {R[][]} raw\n   * @template R\n   */\n  static fromArray(raw) {\n    const map = new Map2d()\n    raw.forEach((row, y) => {\n      row.forEach((value, x) => {\n        map.set(V.vec(x, y), value)\n      })\n    })\n    return map\n  }\n\n  /**\n   *\n   * @param {V.Vec2} pos\n   * @returns {Iterable<V.Vec2>}\n   */\n  #getNeighbors = (pos) =>\n    V.DIRS_4.map((dir) => V.add(pos, dir)).filter((pos) => this.hasPos(pos))\n\n  /**\n   * @type {Map<number, Map<number, T>>}\n   */\n  #data = new Map()\n\n  #minX = Infinity\n  #minY = Infinity\n  #maxX = -Infinity\n  #maxY = -Infinity\n\n  #needRecalculateBounds = false\n\n  get bounds() {\n    if (this.#needRecalculateBounds) {\n      this.#updateBounds()\n    }\n    return {\n      minX: this.#minX,\n      minY: this.#minY,\n      maxX: this.#maxX,\n      maxY: this.#maxY,\n      botRight: V.vec(this.#maxX, this.#maxY),\n      topLeft: V.vec(this.#minX, this.#minY),\n    }\n  }\n\n  get height() {\n    return this.#maxY - this.#minY + 1\n  }\n\n  get width() {\n    return this.#maxX - this.#minX + 1\n  }\n\n  /**\n   * @param {Iterable<[V.Vec2, T]>} [data]\n   */\n  constructor(data = []) {\n    for (const [pos, value] of data) {\n      this.set(pos, value)\n    }\n  }\n\n  #updateBounds() {\n    this.#data.forEach((row, y) => {\n      row.forEach((_, x) => {\n        this.#extendBounds(x, y)\n      })\n    })\n    this.#needRecalculateBounds = false\n  }\n\n  /**\n   * @param {number} x\n   * @param {number} y\n   */\n  #extendBounds(x, y) {\n    this.#minX = Math.min(this.#minX, x)\n    this.#minY = Math.min(this.#minY, y)\n    this.#maxX = Math.max(this.#maxX, x)\n    this.#maxY = Math.max(this.#maxY, y)\n  }\n\n  /**\n   * @param {V.Vec2} vec\n   * @returns {T | undefined}\n   */\n  get([x, y]) {\n    return this.#data.get(x)?.get(y)\n  }\n\n  /**\n   * @param {V.Vec2} vec\n   * @param {T} value\n   * @returns {this}\n   */\n  set([x, y], value) {\n    if (this.#data.has(x) === false) {\n      this.#data.set(x, new Map())\n    }\n    this.#data.get(x).set(y, value)\n\n    this.#extendBounds(x, y)\n    return this\n  }\n\n  /**\n   * @param {V.Vec2} vec\n   */\n  hasPos([x, y]) {\n    return this.#data.get(x)?.has(y) === true\n  }\n\n  /**\n   * @param {(arg: T, pos: V.Vec2) => R} mapFn\n   * @returns {Map2d<R>}\n   *\n   * @template R\n   */\n  map(mapFn) {\n    const result = new Map2d()\n    for (const { pos, value } of this) {\n      result.set(pos, mapFn(value, pos))\n    }\n    return result\n  }\n\n  /**\n   *\n   * @param {(from: BfsPos<T>, to: BfsPos<T>) => boolean} canGoFromTo\n   * @param {V.Vec2} start\n   * @returns {Iterable<BfsPos<T>>}\n   */\n  bfs(canGoFromTo, start) {\n    return bfs(this, canGoFromTo, start, this.#getNeighbors)\n  }\n\n  /**\n   *\n   * @param {(arg: V.Vec2) => Iterable<V.Vec2>} getNeighbors\n   */\n  setGetNeighbors(getNeighbors) {\n    this.#getNeighbors = getNeighbors\n    return this\n  }\n\n  [Symbol.iterator]() {\n    return toIterable(this.#data)\n  }\n\n  /**\n   * @param {Object} params\n   * @param {V.Vec2} [params.topLeftPos]\n   * @param {V.Vec2} [params.botRightPos]\n   * @param {(arg: T | undefined) => J} params.valToString\n   * @returns\n   *\n   * @template J\n   */\n  to2dArray({\n    topLeftPos = V.vec(this.#minX, this.#minY),\n    botRightPos = V.vec(this.#maxX, this.#maxY),\n    valToString,\n  }) {\n    const [minX, minY] = topLeftPos\n    const [maxX, maxY] = botRightPos\n    const result = []\n    for (let y = minY; y <= maxY; y++) {\n      const row = []\n      for (let x = minX; x <= maxX; x++) {\n        const value = this.get([x, y])\n        row.push(valToString(value))\n      }\n      result.push(row)\n    }\n    return result\n  }\n\n  /**\n   * @param {Object} params\n   * @param {V.Vec2} [params.topLeftPos]\n   * @param {V.Vec2} [params.botRightPos]\n   * @param {(arg: T | undefined) => string} [params.valToString]\n   * @returns\n   */\n  toString({\n    topLeftPos = V.vec(this.#minX, this.#minY),\n    botRightPos = V.vec(this.#maxX, this.#maxY),\n    valToString = (x) => (x ?? \".\").toString(),\n  } = {}) {\n    return this.to2dArray({ topLeftPos, botRightPos, valToString })\n      .map((row) => row.join(\"\"))\n      .join(\"\\n\")\n  }\n}\n\n/**\n * @param {T[][]} raw\n * @returns {Map2d<T>}\n * @template T\n */\nexport function toMap2d(raw) {\n  return Map2d.fromArray(raw)\n}\n\n/**\n * @param {string} input\n * @returns\n */\nexport function parseMap2d(input) {\n  const raw = input.split(\"\\n\").map((line) => line.split(\"\"))\n  return Map2d.fromArray(raw)\n}\n\n/**\n * @param {Map<number, Map<number, T>>} map2d\n *\n * @template T\n */\nfunction* toIterable(map2d) {\n  for (const x of map2d.keys()) {\n    for (const y of map2d.get(x).keys()) {\n      yield { pos: V.vec(x, y), value: map2d.get(x).get(y) }\n    }\n  }\n}\n"],"names":["parcelRequire","$cc8aedd9079c178d$export$71a2b7e4ca1456c0","U","R","D","L","UR","UL","$cc8aedd9079c178d$export$ef1ead63b140c91","$cc8aedd9079c178d$export$5dd90d6b3664e0e1","$cc8aedd9079c178d$export$222e698ec63014a5","dir","Error","$cc8aedd9079c178d$export$a785de3a2a8dd1aa","x","y","Math","sign","$cc8aedd9079c178d$export$e16d8520af44a096","x1","y1","x2","y2","$cc8aedd9079c178d$export$f93b5905241a7cca","$cc8aedd9079c178d$export$e588626963949c9c","$cc8aedd9079c178d$export$7f9972325ebfd559","$cc8aedd9079c178d$export$202e0172ed3c7be0","$cc8aedd9079c178d$export$d141bba7fdc215a3","vec","$cc8aedd9079c178d$export$4a5767248b18ef41","$cc8aedd9079c178d$export$9fd36a9547ed1c6f","arg","Array","isArray","length","$cc8aedd9079c178d$export$9663ddc1cf085b32","vecA","vecB","$cc8aedd9079c178d$export$96ec731ed4dcb222","min","$cc8aedd9079c178d$export$8960430cfd85939f","max","$cc8aedd9079c178d$export$6519c25590136c5e","start","end","delta","steps","$cc8aedd9079c178d$export$89ebf43b06e712ad","pos","i","$cc8aedd9079c178d$export$2a1795c9359f92b9","abs","$hyM6K","$12ef29e9c8c24503$export$6bb5b649d10f0d08","input","split","$12ef29e9c8c24503$export$e16d8520af44a096","a","b","$12ef29e9c8c24503$export$65e3907585753458","args","$12ef29e9c8c24503$var$strToType","strVal","type","map","Number","parseInt","endsWith","separator","separators","includes","$12ef29e9c8c24503$var$tryGetSeparator","slice","childType","$12ef29e9c8c24503$export$519f616c41a1c711","$1CMLe","$8bc8d4e2dec9aa33$export$d02631cccf789723","step","undefined","$8bc8d4e2dec9aa33$export$533b26079ad0b4b","iterable","reducer","initial","acc","idx","$8bc8d4e2dec9aa33$export$45b10814cc054894","from","$8bc8d4e2dec9aa33$export$ddf7c77acd0bf516","iterableA","iterableB","iterA","Symbol","iterator","iterB","value","done","doneA","next","doneB","$8bc8d4e2dec9aa33$export$8901015135f2fb22","Infinity","$8bc8d4e2dec9aa33$export$de3a4d4a0d731119","predicate","$8bc8d4e2dec9aa33$export$3486a10f30cf1ee4","returnValue","fn","f","$8bc8d4e2dec9aa33$export$871de8747c9eaa88","groupsOf","n","group","push","$8bc8d4e2dec9aa33$export$25977399ec389b0e","toArray","first","$8bc8d4e2dec9aa33$export$43128fadae87b74a","last","$8bc8d4e2dec9aa33$export$4c7897fafd92b108","find","$8bc8d4e2dec9aa33$export$71aa6c912b956294","skip","$8bc8d4e2dec9aa33$export$955fc4a6c4be454d","take","$8bc8d4e2dec9aa33$export$b7df5d561049483a","toSet","Set","reduce","forEach","filter","$8bc8d4e2dec9aa33$export$3dea766d36a8935f","count","$8bc8d4e2dec9aa33$export$85b9a36db797e02b","indexed","windowed","buffer","shift","$8bc8d4e2dec9aa33$export$5f2b86065ccf5a1","findIndex","indexOf","$8bc8d4e2dec9aa33$export$305f7d4e9d4624f2","flatMap","$8bc8d4e2dec9aa33$export$5b8affa63fc6df16","skipLast","$8bc8d4e2dec9aa33$export$635f6273df29ea1c","takeEvery","every","skipInitial","$8bc8d4e2dec9aa33$export$4e24be1e1c9d5c69","takeWhile","$8bc8d4e2dec9aa33$export$9384c7afe4015e42","takeUntil","$8bc8d4e2dec9aa33$export$ac8dfd3a7ad06e80","$8bc8d4e2dec9aa33$export$7ecc1a3b11b57dab","updateAt","index","$8bc8d4e2dec9aa33$export$b6d8713d53419d4c","unshift","values","$8bc8d4e2dec9aa33$export$37cdb546b806ae87","skipAfter","$8bc8d4e2dec9aa33$export$f5f1500e16a64c4d","sum","add","join","$520099a91db9fbc3$export$8fbd1ac8e83536df","constructor","comparator","this","_heap","_comparator","size","pop","isEmpty","peek","_siftUp","poppedValue","bottom","_swap","_siftDown","replace","replacedValue","_greater","j","node","$520099a91db9fbc3$var$parent","$520099a91db9fbc3$var$left","$520099a91db9fbc3$var$right","maxChild","$e6bef2483974c55d$export$dcc8c5be2e697acf","static","raw","row","set","getNeighbors","DIRS_4","hasPos","data","Map","minX","minY","maxX","maxY","needRecalculateBounds","bounds","updateBounds","botRight","topLeft","height","width","_","extendBounds","get","has","mapFn","result","bfs","canGoFromTo","map2d","queue","isVec","distance","parent","visited","current","key","nextBfs","$e6bef2483974c55d$export$c9e5a085bf83f8b","setGetNeighbors","keys","$e6bef2483974c55d$var$toIterable","to2dArray","topLeftPos","botRightPos","valToString","toString"],"version":3,"file":"index.7024a96b.js.map"}