// @ts-check
const { ESLintUtils, TSESTree } = require("@typescript-eslint/utils")
const ts = require("typescript")
const tsutils = require("tsutils")

module.exports.rules = {
  "solution-format": ESLintUtils.RuleCreator.withoutDocs({
    meta: {
      type: "problem",
      docs: {
        description: "Enforce a consistent format for solution files",
        requiresTypeChecking: true,
        recommended: "error",
      },
      schema: [],
      messages: {
        missingSolveExport:
          'Module must export a function with the name "solve" or functions "part1" and "part2"',
        foundConflictingSolveExports:
          'Module must export either a function "solve" or functions "part1" and "part2"',
        wrongUseExampleType: "useExample must be a boolean",
        wrongExampleType: "exampleInput must be a string",
      },
    },
    create(context) {
      const parserServices = ESLintUtils.getParserServices(context)
      const checker = parserServices.program.getTypeChecker()

      /** @type {Map<string, TSESTree.ExportNamedDeclaration>} */
      const allExports = new Map()

      function checkExports() {
        const solveExport = allExports.get("solve")
        const part1Export = allExports.get("part1")
        const part2Export = allExports.get("part2")
        if (!solveExport && (!part1Export || !part2Export)) {
          context.report({
            messageId: "missingSolveExport",
            loc: { line: 0, column: 0 },
          })
        }
        if (solveExport && (part1Export || part2Export)) {
          context.report({
            node: solveExport,
            messageId: "missingSolveExport",
          })
          if (part1Export) {
            context.report({
              node: part1Export,
              messageId: "missingSolveExport",
            })
          }
          if (part2Export) {
            context.report({
              node: part2Export,
              messageId: "missingSolveExport",
            })
          }
        }

        const useExampleExport = allExports.get("useExample")
        if (useExampleExport && useExampleExport) {
          let type = checker.getTypeAtLocation(
            parserServices.esTreeNodeToTSNodeMap.get(
              useExampleExport.declaration
            )
          )
          if (useExampleExport.declaration.type === "VariableDeclaration") {
            type = checker.getTypeAtLocation(
              parserServices.esTreeNodeToTSNodeMap.get(
                useExampleExport.declaration.declarations[0].init
              )
            )
          }

          if (
            !tsutils.isTypeFlagSet(
              type,
              ts.TypeFlags.Boolean | ts.TypeFlags.BooleanLiteral
            )
          ) {
            context.report({
              node: useExampleExport,
              messageId: "wrongUseExampleType",
              loc: useExampleExport.loc,
            })
          }
        }

        const exampleInputExport = allExports.get("exampleInput")
        if (exampleInputExport) {
          let type = checker.getTypeAtLocation(
            parserServices.esTreeNodeToTSNodeMap.get(
              exampleInputExport.declaration
            )
          )

          if (exampleInputExport.declaration.type === "VariableDeclaration") {
            type = checker.getTypeAtLocation(
              parserServices.esTreeNodeToTSNodeMap.get(
                exampleInputExport.declaration.declarations[0].init
              )
            )
          }

          if (
            !tsutils.isTypeFlagSet(
              type,
              ts.TypeFlags.String | ts.TypeFlags.StringLiteral
            )
          ) {
            context.report({
              node: exampleInputExport,
              messageId: "wrongExampleType",
              loc: exampleInputExport.loc,
            })
          }
        }
      }

      return {
        ExportNamedDeclaration(node) {
          switch (node.declaration.type) {
            case "VariableDeclaration": {
              for (const decl of node.declaration.declarations) {
                if (decl.id.type === "Identifier") {
                  allExports.set(decl.id.name, node)
                }
              }
              break
            }
            case "FunctionDeclaration": {
              allExports.set(node.declaration.id.name, node)
            }
          }
        },
        "Program:exit"() {
          checkExports()
        },
      }
    },
    defaultOptions: [],
  }),
}
