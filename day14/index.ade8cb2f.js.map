{"mappings":"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","sources":["../js/modules/vec.js","../js/modules/itertools.js","../js/modules/lib.js","../js/modules/priority-queue.js","../js/modules/map2d.js","../js/14.js","src/day14/index.js"],"sourcesContent":["// @ts-check\n\n/**\n * @typedef {[x: number, y: number]} Vec2\n */\n\n/**\n * @typedef {\"U\" | \"R\"| \"D\" | \"L\" | \"UR\" | \"UL\"} Dir\n */\n\n/** @type {Record<Dir, Vec2>} */\nexport const DIR_TO_VEC = {\n  U: [0, 1],\n  R: [1, 0],\n  D: [0, -1],\n  L: [-1, 0],\n  UR: [1, 1],\n  UL: [-1, 1],\n}\n\nexport const DIRS_4 = [DIR_TO_VEC.U, DIR_TO_VEC.R, DIR_TO_VEC.D, DIR_TO_VEC.L]\nexport const DIRS_3_TOP = [DIR_TO_VEC.UL, DIR_TO_VEC.U, DIR_TO_VEC.UR]\n\n/**\n *\n * @param {string} dir\n * @returns {Dir}\n */\nexport const asDir = (dir) => {\n  if (dir in DIR_TO_VEC) {\n    return /** @type {Dir} */ (dir)\n  }\n\n  throw new Error(`Invalid direction: ${dir}`)\n}\n\n/**\n *\n * @param {Vec2} vec\n * @returns {Vec2}\n */\nexport const signed = ([x, y]) => [Math.sign(x), Math.sign(y)]\n\n/**\n *\n * @param {Vec2} vecA\n * @param {Vec2} vecB\n * @returns {Vec2}\n */\nexport const add = ([x1, y1], [x2, y2]) => [x1 + x2, y1 + y2]\n\n/**\n *\n * @param {Vec2} vecA\n * @param {Vec2} vecB\n * @returns {Vec2}\n */\nexport const sub = ([x1, y1], [x2, y2]) => [x1 - x2, y1 - y2]\n\n/**\n * @param {Dir} dir\n * @returns {Vec2}\n */\nexport const fromDir = (dir) => DIR_TO_VEC[dir]\n\n/**\n * @returns {Vec2}\n */\nexport const zero = () => [0, 0]\n\n/**\n * @param {number} x\n * @param {number} y\n * @returns {Vec2}\n */\nexport const vec = (x, y) => [x, y]\n\n/**\n * @param {Vec2} vec\n */\nexport const x = (vec) => vec[0]\n\n/**\n * @param {Vec2} vec\n */\nexport const y = (vec) => vec[1]\n\n/**\n * @param {unknown} arg\n * @returns {arg is Vec2}\n */\nexport const isVec = (arg) =>\n  Array.isArray(arg) &&\n  arg.length === 2 &&\n  typeof arg[0] === \"number\" &&\n  typeof arg[1] === \"number\"\n\n/**\n * @param {Vec2} vecA\n * @param {Vec2} vecB\n * @returns {boolean}\n */\nexport const eq = (vecA, vecB) => vecA[0] === vecB[0] && vecA[1] === vecB[1]\n\n/**\n * @param {Vec2} vecA\n * @param {Vec2} vecB\n * @returns {Vec2}\n */\nexport const min = (vecA, vecB) => [\n  Math.min(vecA[0], vecB[0]),\n  Math.min(vecA[1], vecB[1]),\n]\n\n/**\n * @param {Vec2} vecA\n * @param {Vec2} vecB\n * @returns {Vec2}\n */\nexport const max = (vecA, vecB) => [\n  Math.max(vecA[0], vecB[0]),\n  Math.max(vecA[1], vecB[1]),\n]\n\n/**\n * @param {Vec2} start\n * @param {Vec2} end\n */\nexport function* segment(start, end) {\n  const delta = sub(end, start)\n  const dir = signed(delta)\n  const steps = cLen(start, end)\n\n  let pos = start\n  yield pos\n  for (let i = 0; i < steps; i++) {\n    pos = add(pos, dir)\n    yield pos\n  }\n}\n\n/**\n * @type {Vec2}\n */\nexport const ZERO = zero()\n\n/**\n *\n * @param {Vec2} vecA\n * @param {Vec2} vecB\n * @returns {number}\n */\nexport const cLen = (vecA, vecB = zero()) =>\n  Math.max(Math.abs(vecA[0] - vecB[0]), Math.abs(vecA[1] - vecB[1]))\n","// @ts-check\n\nimport { add } from \"./lib.js\"\nimport * as V from \"./vec.js\"\n\n/**\n * @param {number} [start]\n * @param {number} [end]\n * @param {number} [step]\n */\nexport function* range(start, end, step = 1) {\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = start\n    start = 0\n  }\n  if (step === undefined) {\n    step = 1\n  }\n  for (let i = start; i < end; i += step) {\n    yield i\n  }\n}\n\n/**\n * @param {Iterable<T>} iterable\n * @param {number} n\n *\n * @template T\n */\nexport function* skip(iterable, n) {\n  for (const x of iterable) {\n    if (n === 0) {\n      yield x\n    } else {\n      n -= 1\n    }\n  }\n}\n\n/**\n * @param {Iterable<T>} iterable\n * @param {number} n\n *\n * @template T\n */\nexport function* take(iterable, n) {\n  for (const x of iterable) {\n    if (n === 0) {\n      return\n    }\n    yield x\n    n -= 1\n  }\n}\n\n/**\n * @param {Iterable<T>} iterable\n *\n * @template T\n */\nexport function first(iterable) {\n  for (const x of iterable) {\n    return x\n  }\n}\n\n/**\n * @param {Iterable<T>} iterable\n *\n * @template T\n */\nexport function last(iterable) {\n  let last\n  for (const x of iterable) {\n    last = x\n  }\n  return last\n}\n\n/**\n * @param {Iterable<T>} iterable\n * @param {(arg0: R, arg1: T, index: number) => R} reducer\n * @param {R} initial\n *\n * @template T\n * @template R\n */\nexport function reduce(iterable, reducer, initial) {\n  let acc = initial\n  let idx = 0\n  for (const x of iterable) {\n    acc = reducer(acc, x, idx++)\n  }\n  return acc\n}\n\n/**\n *\n * @param {T} x\n * @param {(arg: T) => T} f\n *\n * @template T\n */\nexport function* iterate(x, f) {\n  yield x\n  while (true) {\n    x = f(x)\n    yield x\n  }\n}\n\n/**\n *\n * @param {Iterable<T>} iterable\n * @param {(arg: T) => R} f\n *\n * @template T\n * @template R\n */\nexport function* map(iterable, f) {\n  for (const x of iterable) {\n    yield f(x)\n  }\n}\n\n/**\n *\n * @param {Iterable<T>} iterable\n * @param {number} n\n *\n * @template T\n */\nexport function* groupsOf(iterable, n) {\n  let group = []\n  for (const x of iterable) {\n    group.push(x)\n    if (group.length === n) {\n      yield group\n      group = []\n    }\n  }\n  if (group.length > 0) {\n    yield group\n  }\n}\n\n/**\n * @param {Iterable<T>} iterable\n *\n * @template T\n */\nexport function toArray(iterable) {\n  return Array.from(iterable)\n}\n\n/**\n * @param {Iterable<T>} iterable\n * @param {(value: T) => boolean} predicate\n * @returns {T | undefined}\n * @template T\n */\nexport function find(iterable, predicate) {\n  for (const x of iterable) {\n    if (predicate(x)) {\n      return x\n    }\n  }\n}\n\n/**\n * @param {Iterable<number>} xs\n * @returns\n */\nexport function sum(xs) {\n  return reduce(xs, add, 0)\n}\n\n/**\n * @param {Iterable<T>} iterable\n * @param {(value: T) => boolean} predicate\n * @returns {Iterable<T>}\n * @template T\n */\nexport function* filter(iterable, predicate) {\n  for (const x of iterable) {\n    if (predicate(x)) {\n      yield x\n    }\n  }\n}\n\n/**\n * @param {Iterable<T>} iterable\n * @param {(value: T) => boolean} [predicate]\n * @returns {number}\n * @template T\n */\nexport function count(iterable, predicate = () => true) {\n  let count = 0\n  for (const x of iterable) {\n    if (predicate(x)) {\n      count += 1\n    }\n  }\n  return count\n}\n\n/**\n *\n * @param {Iterable<T>} iterableA\n * @param {Iterable<U>} iterableB\n * @returns {Iterable<[T, U]>}\n *\n * @template T, U\n */\nexport function* zip(iterableA, iterableB) {\n  const iterA = iterableA[Symbol.iterator]()\n  const iterB = iterableB[Symbol.iterator]()\n  while (true) {\n    const { value: a, done: doneA } = iterA.next()\n    const { value: b, done: doneB } = iterB.next()\n    if (doneA || doneB) {\n      return\n    }\n    yield [a, b]\n  }\n}\n\n/**\n *\n * @param {Iterable<T>} iterable\n * @returns {Iterable<[number, T]>}\n *\n * @template T\n */\nexport function indexed(iterable) {\n  return zip(range(Infinity), iterable)\n}\n\n/**\n *\n * @param {Iterable<T>} iterable\n * @param {number} n\n * @returns {Iterable<T[]>}\n *\n * @template T\n */\nexport function* windowed(iterable, n) {\n  const buffer = []\n  for (const x of iterable) {\n    buffer.push(x)\n    if (buffer.length === n) {\n      yield buffer\n      buffer.shift()\n    }\n  }\n}\n\n/**\n * @param {Iterable<T>} iterable\n * @param {(value: T) => boolean} predicate\n * @returns {number}\n * @template T\n */\nexport function findIndex(iterable, predicate) {\n  let i = 0\n  for (const x of iterable) {\n    if (predicate(x)) {\n      return i\n    }\n    i++\n  }\n  return -1\n}\n\n/**\n *\n * @param {Iterable<T>} iterable\n * @param {T} value\n * @returns {number}\n *\n * @template T\n */\nexport function indexOf(iterable, value) {\n  return findIndex(iterable, (x) => x === value)\n}\n\n/**\n *\n * @param {Iterable<T>} iterable\n * @param {(arg: T) => Iterable<R>} f\n * @returns {Iterable<R>}\n *\n * @template T, R\n */\nexport function* flatMap(iterable, f) {\n  for (const x of iterable) {\n    yield* f(x)\n  }\n}\n\n/**\n * @param {Iterable<T>} iterable\n * @param {number} [n]\n * @returns {Iterable<T>}\n *\n * @template T\n */\nexport function* skipLast(iterable, n = 1) {\n  if (n <= 0) {\n    yield* iterable\n    return\n  }\n\n  const buffer = Array(n)\n  let i = 0\n  for (const x of iterable) {\n    if (i >= n) {\n      yield buffer[i % n]\n    }\n    buffer[i % n] = x\n    i++\n  }\n}\n\n/**\n *\n * @param {Iterable<T>} iterable\n * @param {number} every\n * @param {number} [skipInitial]\n * @returns {Iterable<T>}\n *\n * @template T\n */\nexport function* takeEvery(iterable, every, skipInitial = 0) {\n  if (every <= 0) {\n    return\n  }\n  if (skipInitial < 0) {\n    skipInitial = 0\n  }\n\n  for (const x of iterable) {\n    if (skipInitial === 0) {\n      yield x\n      skipInitial = every\n    }\n    skipInitial--\n  }\n}\n\n/**\n * @param {Iterable<T>} iterable\n * @param {(value: T) => boolean} predicate\n * @returns {Iterable<T>}\n * @template T\n */\nexport function* takeWhile(iterable, predicate) {\n  for (const x of iterable) {\n    if (!predicate(x)) {\n      return\n    }\n    yield x\n  }\n}\n\n/**\n * @param {Iterable<T>} iterable\n * @param {(value: T) => boolean} predicate\n * @returns {Iterable<T>}\n * @template T\n */\nexport function* takeUntil(iterable, predicate) {\n  for (const x of iterable) {\n    if (predicate(x)) {\n      return\n    }\n    yield x\n  }\n}\n\n/**\n * @param {Iterable<T>} iterable\n * @param {(value: T) => boolean} predicate\n * @returns {boolean}\n * @template T\n */\nexport function every(iterable, predicate) {\n  for (const x of iterable) {\n    if (!predicate(x)) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n *\n * @param {Iterable<T>} iterable\n * @param {number} index\n * @param {(arg: T) => T} fn\n *\n * @template T\n */\nexport function* updateAt(iterable, index, fn) {\n  let i = 0\n  for (const x of iterable) {\n    if (i === index) {\n      yield fn(x)\n    } else {\n      yield x\n    }\n    i++\n  }\n}\n\n/**\n *\n * @param {Iterable<T>} iterable\n * @param  {T[]} values\n *\n * @template T\n */\nexport function* unshift(iterable, ...values) {\n  yield* values\n  yield* iterable\n}\n\n/**\n * @param {Iterable<T>} iterable\n * @param {(value: T) => boolean} predicate\n * @returns {Iterable<T>}\n * @template T\n */\nexport function* skipAfter(iterable, predicate) {\n  for (const x of iterable) {\n    yield x\n    if (predicate(x)) {\n      return\n    }\n  }\n}\n\n/**\n * @typedef {Iterable<T> & {\n *    map: <R>(fn: (arg: T) => R) => FluentIterable<R>\n *    groupsOf: (n: number) => FluentIterable<T[]>\n *    toArray: () => T[]\n *    first: () => T | undefined\n *    last: () => T | undefined\n *    find: (predicate: (arg: T) => boolean) => T | undefined\n *    skip: (n: number) => FluentIterable<T>\n *    take: (n: number) => FluentIterable<T>\n *    toSet: () => Set<T>\n *    reduce: <R>(reducer: (arg0: R, arg1: T, index: number) => R, init: R) => R\n *    forEach: (fn: (arg: T) => void) => void\n *    count: (predicate?: (arg: T) => boolean) => number\n *    filter: (predicate: (arg: T) => boolean) => FluentIterable<T>\n *    indexed: () => FluentIterable<[number, T]>\n *    windowed: (n: number) => FluentIterable<T[]>\n *    findIndex: (predicate: (arg: T) => boolean) => number\n *    indexOf : (value: T) => number\n *    flatMap: <R>(f: (arg: T) => Iterable<R>) => FluentIterable<R>\n *    skipLast: (n?: number) => FluentIterable<T>\n *    takeEvery: (every: number, skipInitial?: number) => FluentIterable<T>\n *    takeWhile: (predicate: (arg: T) => boolean) => FluentIterable<T>\n *    takeUntil: (predicate: (arg: T) => boolean) => FluentIterable<T>\n *    every: (predicate: (arg: T) => boolean) => boolean\n *    updateAt: (index: number, fn: (arg: T) => T) => FluentIterable<T>\n *    unshift: (...values: T[]) => FluentIterable<T>\n *    skipAfter: (predicate: (arg: T) => boolean) => FluentIterable<T>\n * }} GenericFluentIterable<T>\n *\n *\n * @template T\n */\n\n/**\n * @typedef {GenericFluentIterable<string> & {\n *    join: (separator?: string) => string\n * }} StrFluentIterable\n */\n\n/**\n * @typedef {GenericFluentIterable<number> & {\n *    sum: () => number\n *    min: () => number\n *    max: () => number\n * }} NumFluentIterable\n */\n\n/**\n * @typedef {T extends number\n *    ? NumFluentIterable\n *    : T extends boolean\n *    ? GenericFluentIterable<boolean>\n *    : T extends string\n *    ? StrFluentIterable\n *    : T extends infer U ? GenericFluentIterable<U> : never} FluentIterable\n * @template T\n */\n\n/**\n *\n * @param {Iterable<T>} iterable\n * @returns {FluentIterable<T>}\n * @template T\n */\nexport const it = (iterable) => {\n  /**\n   * @type {FluentIterable<any>}\n   */\n  const returnValue = {\n    //#region GenericFluentIterable methods\n    [Symbol.iterator]: () => iterable[Symbol.iterator](),\n    /** @type {<R>(fn: (arg: T) => R) => FluentIterable<R>} */\n    map: (fn) => it(map(iterable, fn)),\n    groupsOf: (n) => it(groupsOf(iterable, n)),\n    toArray: () => toArray(iterable),\n    first: () => first(iterable),\n    last: () => last(iterable),\n    find: (/** @type {(value: T) => boolean} */ predicate) =>\n      find(iterable, predicate),\n    skip: (n) => it(skip(iterable, n)),\n    take: (n) => it(take(iterable, n)),\n    toSet: () => new Set(iterable),\n    /** @type {<R>(reducer: (arg0: R, arg1: T, index: number) => R, init: R) => R} */\n    reduce: (reducer, initial) => reduce(iterable, reducer, initial),\n    /** @type {(fn: (arg: T) => void) => void} */\n    forEach: (fn) => {\n      for (const x of iterable) {\n        fn(x)\n      }\n    },\n    filter: (/** @type {(arg: T) => boolean} */ predicate) =>\n      it(filter(iterable, predicate)),\n    count: (/** @type {((arg: T) => boolean) | undefined} */ predicate) =>\n      count(iterable, predicate),\n    indexed: () => it(indexed(iterable)),\n    windowed: (n) => it(windowed(iterable, n)),\n    findIndex: (/** @type {(arg: T) => boolean} */ predicate) =>\n      findIndex(iterable, predicate),\n    indexOf: (/** @type {T} */ value) => indexOf(iterable, value),\n    /** @type {<R>(f: (arg: T) => Iterable<R>) => FluentIterable<R>} */\n    flatMap: (f) => it(flatMap(iterable, f)),\n    skipLast: (n) => it(skipLast(iterable, n)),\n    takeEvery: (every, skipInitial) =>\n      it(takeEvery(iterable, every, skipInitial)),\n    takeWhile: (/** @type {(arg: T) => boolean} */ predicate) =>\n      it(takeWhile(iterable, predicate)),\n    takeUntil: (/** @type {(arg: T) => boolean} */ predicate) =>\n      it(takeUntil(iterable, predicate)),\n    every: (/** @type {(arg: T) => boolean} */ predicate) =>\n      every(iterable, predicate),\n    updateAt: (/** @type {number} */ index, /** @type {(arg: T) => T} */ fn) =>\n      it(updateAt(iterable, index, fn)),\n    unshift: (/** @type {T[]} */ ...values) => it(unshift(iterable, ...values)),\n    skipAfter: (/** @type {(arg: T) => boolean} */ predicate) =>\n      it(skipAfter(iterable, predicate)),\n    //#endregion\n\n    //#region NumFluentIterable methods\n    sum: () => sum(/** @type {Iterable<number>} */ (iterable)),\n    min: () =>\n      /** @type {NumFluentIterable} */ (returnValue).reduce(Math.min, Infinity),\n    max: () =>\n      /** @type {NumFluentIterable} */ (returnValue).reduce(\n        Math.max,\n        -Infinity,\n      ),\n    //#endregion\n\n    //#region StrFluentIterable methods\n    join: (separator = \",\") => toArray(iterable).join(separator),\n    //#endregion\n  }\n  return /** @type {FluentIterable<T>} */ (returnValue)\n}\n","// @ts-check\n\nimport { V } from \"./index.js\"\nimport { it } from \"./itertools.js\"\n\n/**\n * @param {T} x\n * @returns {T}\n * @template T\n */\nexport function id(x) {\n  return x\n}\n\n/**\n * @param {T[]} xs\n * @param {(arg: T) => string | number} fn\n *\n * @template T\n */\nexport function minBy(xs, fn) {\n  return xs.reduce((a, b) => (fn(a) < fn(b) ? a : b))\n}\n\n/**\n * @param {T[]} xs\n * @param {(arg: T) => string | number} fn\n *\n * @template T\n */\nexport function maxBy(xs, fn) {\n  return xs.reduce((a, b) => (fn(a) > fn(b) ? a : b))\n}\n\n/**\n * @param {number[]} xs\n */\nexport function min(xs) {\n  return minBy(xs, id)\n}\n\n/**\n * @param {number[]} xs\n */\nexport function max(xs) {\n  return maxBy(xs, id)\n}\n\n/**\n *\n * @param {T[]} xs\n * @param {T[][]} yss\n * @returns {T[][]}\n *\n * @template T\n */\nexport function zip(xs, ...yss) {\n  const minLength = minBy(yss, (ys) => ys.length).length\n  return xs.slice(0, minLength).map((val, i) =>\n    yss.reduce(\n      (a, arr) => {\n        a.push(arr[i])\n        return a\n      },\n      [val],\n    ),\n  )\n}\n\n/**\n * @param {string} input\n */\nexport function readLines(input) {\n  return input.split(\"\\n\")\n}\n\n/**\n * @param {string} input\n */\nexport function readBlocks(input) {\n  return input.split(\"\\n\\n\")\n}\n\n/**\n * @param {string} input\n * @returns\n */\nexport function readIntLines(input) {\n  return readLines(input).map(Number)\n}\n\n/**\n * @param {string} input\n * @param {string} [separator]\n */\nexport function readIntArr(input, separator = \",\") {\n  return input.split(separator).map(Number)\n}\n\n/**\n *\n * @param {T} value\n * @template T\n */\nexport function functor(value) {\n  return {\n    /**\n     *\n     * @param {(arg: T) => R} fn\n     * @template R\n     */\n    map(fn) {\n      return functor(fn(value))\n    },\n    get() {\n      return value\n    },\n  }\n}\n\n/**\n * @param {T[]} xs\n * @param {number} n\n * @template T\n */\nexport function cycle(xs, n) {\n  return xs.slice(n).concat(xs.slice(0, n))\n}\n\n/**\n * @param {T[]} xs\n * @param {number} n\n * @template T\n */\nexport function at(xs, n) {\n  if (n < 0) {\n    n = xs.length + n\n  }\n  return xs[n]\n}\n\n/**\n * @param {number} a\n * @param {number} b\n * @returns\n */\nexport function add(a, b) {\n  return a + b\n}\n\n/**\n * @param {number} a\n * @param {number} b\n * @returns\n */\nexport function mul(a, b) {\n  return a * b\n}\n\n/**\n * @param {number} a\n * @param {number} b\n * @returns\n */\nexport function compareAsc(a, b) {\n  return a - b\n}\n\n/**\n * @param {number} a\n * @param {number} b\n * @returns\n */\nexport function compareDesc(a, b) {\n  return b - a\n}\n\n/**\n *\n * @param {T[]} xs\n * @param {number} i\n * @param {(arg: T) => T} fn\n *\n * @template T\n */\nexport function update(xs, i, fn) {\n  return xs\n    .slice(0, i)\n    .concat(fn(xs[i]))\n    .concat(xs.slice(i + 1))\n}\n\n/**\n * @param {number} x\n */\nexport function inc(x) {\n  return x + 1\n}\n\n/**\n * @param {T} xs\n * @param {number} n\n * @returns {[T, T]}\n *\n * @template {{slice(start: number, end?: number): T}} T\n */\nexport function splitAt(xs, n) {\n  return [xs.slice(0, n), xs.slice(n)]\n}\n\n/**\n *\n * @param {T[][]} arr\n * @param {boolean} clockwise\n * @returns {T[][]}\n *\n * @template T\n */\nexport function rotate2d(arr, clockwise = true) {\n  const height = arr.length\n  const width = it(arr)\n    .map((line) => line.length)\n    .max()\n\n  const rotated = Array.from({ length: width }, () =>\n    Array.from({ length: height }),\n  )\n\n  for (let y = 0; y < height; y++) {\n    for (let x = 0; x < width; x++) {\n      const value = arr[y]?.[x]\n      const [i, j] = clockwise ? [x, height - y - 1] : [width - x - 1, y]\n      rotated[i][j] = value\n    }\n  }\n\n  return rotated\n}\n\n/**\n *\n * @param {string[]} strings\n * @param {boolean} clockwise\n */\nexport function rotateStrings2d(strings, clockwise = true) {\n  const rotated = rotate2d(\n    strings.map((str) => str.split(\"\")),\n    clockwise,\n  )\n\n  return rotated.map((line) =>\n    line\n      .map((x) => x ?? \" \")\n      .join(\"\")\n      .trimEnd(),\n  )\n}\n\n/**\n *\n * @param {string} str\n * @param {boolean} [clockwise]\n *\n * @returns {string}\n */\nexport function rotateString2d(str, clockwise = true) {\n  return rotateStrings2d(str.split(\"\\n\"), clockwise).join(\"\\n\")\n}\n\n/**\n *\n * @param  {T} args\n * @returns {T}\n *\n * @template {unknown[]} T\n */\nexport function tuple(...args) {\n  return args\n}\n\n/**\n * @type {import(\"./types.js\").RotateFn}\n *\n * @template T\n */\n// @ts-ignore\nexport const rotate = (\n  /** @type {string | string[] | T[][]} */ rotatable,\n  clockwise = true,\n) => {\n  if (typeof rotatable === \"string\") {\n    return rotateString2d(rotatable, clockwise)\n  }\n  if (typeof rotatable[0] === \"string\") {\n    return rotateStrings2d(/** @type {string[]} */ (rotatable), clockwise)\n  }\n  return rotate2d(/** @type {T[][]} */ (rotatable), clockwise)\n}\n\n/**\n * @param {string} strVal\n */\nfunction tryGetSeparator(strVal) {\n  const separators = [\" -> \", \", \", \",\", \" - \", \"-\", \" \"]\n  for (const separator of separators) {\n    if (strVal.includes(separator)) {\n      return separator\n    }\n  }\n  return null\n}\n\n/**\n * @param {string} strVal\n * @param {string} type\n *\n * @returns {unknown}\n */\nfunction strToType(strVal, type) {\n  if (!type) {\n    return strVal\n  }\n  if (type === \"vec\") {\n    const [x, y] = strVal.split(\",\").map(Number)\n    return V.vec(x, y)\n  }\n  if (type === \"int\") {\n    return parseInt(strVal, 10)\n  }\n  if (type.endsWith(\"[]\")) {\n    const separator = tryGetSeparator(strVal)\n    if (!separator) {\n      return [strToType(strVal, type.slice(0, -2))]\n    }\n    const childType = type.slice(0, -2)\n    return strVal.split(separator).map((x) => strToType(x, childType))\n  }\n  return strVal\n}\n\n/**\n * @param {T} type\n * @returns {(strVal: string) => import(\"./types.js\").TemplateValueReturnType<T>}\n *\n * @template {string} T\n */\nexport function typed(type) {\n  return (strVal) =>\n    /** @type {import(\"./types.js\").TemplateValueReturnType<T>} */ (\n      strToType(strVal, type)\n    )\n}\n\n/**\n * @param {TemplateStringsArray} strings\n * @param  {T} keys\n *\n * @template {string[]} T\n */\nexport function tpl(strings, ...keys) {\n  /**\n   * @param {string} input\n   * @returns {{[P in T[number] as import(\"./types.js\").TemplateKey<P>]: import(\"./types.js\").TemplateValue<P> }}\n   */\n  function parse(input) {\n    /** @type {Record<string, any>} */\n    const model = {}\n    let lastIndex = 0\n    for (let i = 0; i < keys.length; i++) {\n      const start = strings[i].length + lastIndex\n      const end = strings[i + 1]\n        ? input.indexOf(strings[i + 1], start)\n        : input.length\n      const strVal = input.slice(start, end)\n      const [key, type] = keys[i].split(\"|\")\n      model[key] = strToType(strVal, type)\n      lastIndex = end\n    }\n    return /** @type {any} */ (model)\n  }\n\n  /**\n   * @param {(arg: ReturnType<typeof parse>) => R} fn\n   * @template R\n   */\n  parse.map = (fn) => (/** @type {string} */ input) => fn(parse(input))\n\n  return parse\n}\n","// @ts-check\n// https://stackoverflow.com/a/42919752\n\nconst top = 0\nconst parent = (/** @type {number} */ i) => ((i + 1) >>> 1) - 1\nconst left = (/** @type {number} */ i) => (i << 1) + 1\nconst right = (/** @type {number} */ i) => (i + 1) << 1\n\n/**\n * @template T\n * @implements {Iterable<T>}\n */\nexport class PriorityQueue {\n  /**\n   *\n   * @param {(a: T, b: T) => number} comparator\n   */\n  constructor(comparator = (a, b) => Number(a > b)) {\n    /** @type {T[]} @private */\n    this._heap = []\n    /** @private */\n    this._comparator = comparator\n  }\n\n  [Symbol.iterator]() {\n    return {\n      next: () => {\n        if (this.size() > 1) {\n          return { value: this.pop(), done: false }\n        }\n        return { done: true, value: this.pop() }\n      },\n    }\n  }\n\n  size() {\n    return this._heap.length\n  }\n  isEmpty() {\n    return this.size() == 0\n  }\n  peek() {\n    return this._heap[top]\n  }\n  /**\n   * @param  {T[]} values\n   * @returns\n   */\n  push(...values) {\n    values.forEach((value) => {\n      this._heap.push(value)\n      this._siftUp()\n    })\n    return this.size()\n  }\n  pop() {\n    const poppedValue = this.peek()\n    const bottom = this.size() - 1\n    if (bottom > top) {\n      this._swap(top, bottom)\n    }\n    this._heap.pop()\n    this._siftDown()\n    return poppedValue\n  }\n  /**\n   * @param {T} value\n   */\n  replace(value) {\n    const replacedValue = this.peek()\n    this._heap[top] = value\n    this._siftDown()\n    return replacedValue\n  }\n  /**\n   * @param {number} i\n   * @param {number} j\n   * @private\n   */\n  _greater(i, j) {\n    return this._comparator(this._heap[i], this._heap[j]) < 0\n  }\n  /**\n   * @param {number} i\n   * @param {number} j\n   * @private\n   */\n  _swap(i, j) {\n    ;[this._heap[i], this._heap[j]] = [this._heap[j], this._heap[i]]\n  }\n  /**\n   * @private\n   */\n  _siftUp() {\n    let node = this.size() - 1\n    while (node > top && this._greater(node, parent(node))) {\n      this._swap(node, parent(node))\n      node = parent(node)\n    }\n  }\n  /**\n   * @private\n   */\n  _siftDown() {\n    let node = top\n    while (\n      (left(node) < this.size() && this._greater(left(node), node)) ||\n      (right(node) < this.size() && this._greater(right(node), node))\n    ) {\n      let maxChild =\n        right(node) < this.size() && this._greater(right(node), left(node))\n          ? right(node)\n          : left(node)\n      this._swap(node, maxChild)\n      node = maxChild\n    }\n  }\n}\n","// @ts-check\n\nimport { it } from \"./itertools.js\"\nimport * as V from \"./vec.js\"\n\n/**\n * @typedef {Object} BfsPos\n * @property {V.Vec2} pos\n * @property {number} distance\n * @property {T} value\n * @property {BfsPos<T>} [parent]\n *\n * @template T\n */\n\n/**\n *\n * @param {Map2d<T>} map2d\n * @param {(from: BfsPos<T>, to: BfsPos<T>) => boolean} canGoFromTo\n * @param {V.Vec2 | Iterable<V.Vec2>} start\n * @param {(pos: V.Vec2) => Iterable<V.Vec2>} getNeighbors\n *\n * @template T\n */\nexport function* bfs(map2d, canGoFromTo, start, getNeighbors) {\n  /** @type {BfsPos<T>[]} */\n  const queue = []\n\n  if (V.isVec(start)) {\n    queue.push({\n      distance: 0,\n      pos: start,\n      value: map2d.get(start),\n      parent: null,\n    })\n  } else {\n    for (const pos of start) {\n      queue.push({\n        distance: 0,\n        pos: pos,\n        value: map2d.get(pos),\n        parent: null,\n      })\n    }\n  }\n\n  const visited = new Set()\n\n  while (queue.length) {\n    const current = queue.shift()\n    const key = current.pos.join()\n    if (visited.has(key)) continue\n    visited.add(key)\n\n    yield current\n\n    for (const next of getNeighbors(current.pos)) {\n      const nextBfs = {\n        distance: current.distance + 1,\n        pos: next,\n        value: map2d.get(next),\n        parent: current,\n      }\n\n      if (canGoFromTo(current, nextBfs)) {\n        queue.push(nextBfs)\n      }\n    }\n  }\n}\n\n/**\n * @implements {Iterable<{pos: V.Vec2;value: T;}>}\n * @template T\n */\nexport class Map2d {\n  /**\n   * @param {R[][]} raw\n   * @template R\n   */\n  static fromArray(raw) {\n    const map = new Map2d()\n    raw.forEach((row, y) => {\n      row.forEach((value, x) => {\n        map.set(V.vec(x, y), value)\n      })\n    })\n    return map\n  }\n\n  /**\n   *\n   * @param {V.Vec2} pos\n   * @returns {Iterable<V.Vec2>}\n   */\n  #getNeighbors = (pos) =>\n    V.DIRS_4.map((dir) => V.add(pos, dir)).filter((pos) => this.hasPos(pos))\n\n  /**\n   * @type {Map<number, Map<number, T>>}\n   */\n  #data = new Map()\n\n  #minX = Infinity\n  #minY = Infinity\n  #maxX = -Infinity\n  #maxY = -Infinity\n\n  #needRecalculateBounds = false\n\n  get bounds() {\n    if (this.#needRecalculateBounds) {\n      this.#updateBounds()\n    }\n    return {\n      minX: this.#minX,\n      minY: this.#minY,\n      maxX: this.#maxX,\n      maxY: this.#maxY,\n      botRight: V.vec(this.#maxX, this.#maxY),\n      topLeft: V.vec(this.#minX, this.#minY),\n    }\n  }\n\n  get height() {\n    return this.#maxY - this.#minY + 1\n  }\n\n  get width() {\n    return this.#maxX - this.#minX + 1\n  }\n\n  /**\n   * @param {Iterable<[V.Vec2, T]>} [data]\n   */\n  constructor(data = []) {\n    for (const [pos, value] of data) {\n      this.set(pos, value)\n    }\n  }\n\n  #updateBounds() {\n    this.#data.forEach((row, y) => {\n      row.forEach((_, x) => {\n        this.#extendBounds(x, y)\n      })\n    })\n    this.#needRecalculateBounds = false\n  }\n\n  /**\n   * @param {number} x\n   * @param {number} y\n   */\n  #extendBounds(x, y) {\n    this.#minX = Math.min(this.#minX, x)\n    this.#minY = Math.min(this.#minY, y)\n    this.#maxX = Math.max(this.#maxX, x)\n    this.#maxY = Math.max(this.#maxY, y)\n  }\n\n  /**\n   * @param {V.Vec2} vec\n   * @returns {T | undefined}\n   */\n  get([x, y]) {\n    return this.#data.get(x)?.get(y)\n  }\n\n  /**\n   * @param {V.Vec2} vec\n   * @param {T} value\n   * @returns {this}\n   */\n  set([x, y], value) {\n    if (this.#data.has(x) === false) {\n      this.#data.set(x, new Map())\n    }\n    this.#data.get(x).set(y, value)\n\n    this.#extendBounds(x, y)\n    return this\n  }\n\n  /**\n   * @param {V.Vec2} vec\n   */\n  hasPos([x, y]) {\n    return this.#data.get(x)?.has(y) === true\n  }\n\n  /**\n   * @param {(arg: T, pos: V.Vec2) => R} mapFn\n   * @returns {Map2d<R>}\n   *\n   * @template R\n   */\n  map(mapFn) {\n    const result = new Map2d()\n    for (const { pos, value } of this) {\n      result.set(pos, mapFn(value, pos))\n    }\n    return result\n  }\n\n  /**\n   *\n   * @param {(from: BfsPos<T>, to: BfsPos<T>) => boolean} canGoFromTo\n   * @param {V.Vec2} start\n   * @returns {Iterable<BfsPos<T>>}\n   */\n  bfs(canGoFromTo, start) {\n    return bfs(this, canGoFromTo, start, this.#getNeighbors)\n  }\n\n  /**\n   *\n   * @param {(arg: V.Vec2) => Iterable<V.Vec2>} getNeighbors\n   */\n  setGetNeighbors(getNeighbors) {\n    this.#getNeighbors = getNeighbors\n    return this\n  }\n\n  [Symbol.iterator]() {\n    return toIterable(this.#data)\n  }\n\n  /**\n   * @param {Object} params\n   * @param {V.Vec2} [params.topLeftPos]\n   * @param {V.Vec2} [params.botRightPos]\n   * @param {(arg: T | undefined) => J} params.valToString\n   * @returns\n   *\n   * @template J\n   */\n  to2dArray({\n    topLeftPos = V.vec(this.#minX, this.#minY),\n    botRightPos = V.vec(this.#maxX, this.#maxY),\n    valToString,\n  }) {\n    const [minX, minY] = topLeftPos\n    const [maxX, maxY] = botRightPos\n    const result = []\n    for (let y = minY; y <= maxY; y++) {\n      const row = []\n      for (let x = minX; x <= maxX; x++) {\n        const value = this.get([x, y])\n        row.push(valToString(value))\n      }\n      result.push(row)\n    }\n    return result\n  }\n\n  /**\n   * @param {Object} params\n   * @param {V.Vec2} [params.topLeftPos]\n   * @param {V.Vec2} [params.botRightPos]\n   * @param {(arg: T | undefined) => string} [params.valToString]\n   * @returns\n   */\n  toString({\n    topLeftPos = V.vec(this.#minX, this.#minY),\n    botRightPos = V.vec(this.#maxX, this.#maxY),\n    valToString = (x) => (x ?? \".\").toString(),\n  } = {}) {\n    return this.to2dArray({ topLeftPos, botRightPos, valToString })\n      .map((row) => row.join(\"\"))\n      .join(\"\\n\")\n  }\n}\n\n/**\n * @param {T[][]} raw\n * @returns {Map2d<T>}\n * @template T\n */\nexport function toMap2d(raw) {\n  return Map2d.fromArray(raw)\n}\n\n/**\n * @param {string} input\n * @returns\n */\nexport function parseMap2d(input) {\n  const raw = input.split(\"\\n\").map((line) => line.split(\"\"))\n  return Map2d.fromArray(raw)\n}\n\n/**\n * @param {Map<number, Map<number, T>>} map2d\n *\n * @template T\n */\nfunction* toIterable(map2d) {\n  for (const x of map2d.keys()) {\n    for (const y of map2d.get(x).keys()) {\n      yield { pos: V.vec(x, y), value: map2d.get(x).get(y) }\n    }\n  }\n}\n","// @ts-check\n\nimport { V } from \"./modules/index.js\"\nimport { it } from \"./modules/itertools.js\"\nimport { readLines, tuple, typed } from \"./modules/lib.js\"\nimport { Map2d } from \"./modules/map2d.js\"\n\n/**\n * @param {string} input\n * @returns\n */\nexport function solve(input) {\n  return [() => part1(input), () => part2(input)]\n}\n\nconst start = V.vec(500, 0)\n\n/**\n * @param {string} input\n * @returns\n */\nexport function parseMap(input) {\n  const lines = readLines(input.trimEnd()).map(typed(\"vec[]\"))\n\n  const points = it(lines)\n    .flatMap((line) =>\n      it(line)\n        .windowed(2)\n        .flatMap(([a, b]) => V.segment(a, b)),\n    )\n    .map((pos) => tuple(pos, \"#\"))\n\n  return new Map2d(points).set(start, \"+\")\n}\n\n/**\n * @param {Map2d<string>} map2d\n */\nexport function* simulateSand(map2d, maxY = map2d.bounds.maxY) {\n  const bot = V.vec(0, 1)\n  const leftBot = V.vec(-1, 1)\n  const rightBot = V.vec(1, 1)\n\n  /**\n   *\n   * @param {V.Vec2} startFrom\n   * @returns\n   */\n  function drop(startFrom) {\n    let pos = startFrom\n    while (true) {\n      if (V.y(pos) >= maxY) {\n        return null\n      }\n\n      const bottom = V.add(pos, bot)\n      if (map2d.hasPos(bottom) === false) {\n        pos = bottom\n        continue\n      }\n\n      const lb = V.add(pos, leftBot)\n      if (map2d.hasPos(lb) === false) {\n        pos = lb\n        continue\n      }\n\n      const rb = V.add(pos, rightBot)\n      if (map2d.hasPos(rb) === false) {\n        pos = rb\n        continue\n      }\n\n      return pos\n    }\n  }\n\n  while (true) {\n    const pos = drop(start)\n    if (pos === null || V.eq(pos, start)) {\n      return\n    }\n    map2d.set(pos, \"o\")\n    yield pos\n  }\n}\n\n/**\n * @param {string} input\n */\nfunction part1(input) {\n  const map2d = parseMap(input)\n\n  return it(simulateSand(map2d)).count()\n}\n\n/**\n * @param {string} input\n */\nfunction part2(input) {\n  const map = parseMap(input)\n\n  const bfs = map\n    .setGetNeighbors((pos) => V.DIRS_3_TOP.map((d) => V.add(pos, d)))\n    .bfs((_, b) => !map.hasPos(b.pos) && b.pos[1] < map.height + 2, start)\n\n  return it(bfs).count()\n}\n","// @ts-check\nimport { simulateSand, parseMap } from \"../../../js/14.js\"\n\nconst canvas = document.getElementById(\"canvas\")\nif (!(canvas instanceof HTMLCanvasElement)) throw new Error(\"no canvas\")\n\nconst ctx = canvas.getContext(\"2d\")\nif (!ctx) throw new Error(\"no ctx\")\n\nlet interval = 0\n/**\n * @param {string} input\n * @param {CanvasRenderingContext2D} ctx\n */\nfunction draw(input, ctx) {\n  clearInterval(interval)\n  const map = parseMap(input)\n  const { width, height, bounds } = map\n  const scale = Math.min(10, Math.max(4, 100 / width))\n\n  ctx.canvas.width = width * scale\n  ctx.canvas.height = height * scale\n\n  ctx.canvas.scrollIntoView({ behavior: \"smooth\" })\n\n  const colors = {\n    \"+\": \"orange\",\n    o: \"orange\",\n    \"#\": \"gray\",\n    \".\": \"darkblue\",\n  }\n\n  const iter = simulateSand(map)\n  const first = (iter.next().value?.[1] ?? 0) - bounds.minY\n\n  function drawState() {\n    const map2dStr = map.to2dArray({ valToString: (x) => x ?? \".\" })\n\n    map2dStr.forEach((row, y) => {\n      row.forEach((cell, x) => {\n        ctx.fillStyle = colors[cell]\n        ctx.fillRect(x * scale, y * scale, scale, scale)\n      })\n    })\n\n    let x = 500 - bounds.minX\n    for (let y = 0; y <= first; y++) {\n      ctx.fillStyle = colors[\"o\"]\n      ctx.fillRect(x * scale, y * scale, scale, scale)\n    }\n  }\n\n  drawState()\n\n  interval = setInterval(() => {\n    iter.next()\n    drawState()\n  }, 33)\n}\n\nconst inputForm = document.getElementById(\"input-form\")\nif (!(inputForm instanceof HTMLFormElement)) throw new Error(\"no form\")\n\ninputForm.addEventListener(\"submit\", function (e) {\n  e.preventDefault()\n  const formData = new FormData(this)\n  const input = formData.get(\"input\")?.toString() ?? \"\"\n  draw(input.trim(), ctx)\n})\n"],"names":["$cc8aedd9079c178d$export$71a2b7e4ca1456c0","U","R","D","L","UR","UL","$cc8aedd9079c178d$export$ef1ead63b140c91","$cc8aedd9079c178d$export$5dd90d6b3664e0e1","$cc8aedd9079c178d$export$222e698ec63014a5","dir","Error","$cc8aedd9079c178d$export$a785de3a2a8dd1aa","x","y","Math","sign","$cc8aedd9079c178d$export$e16d8520af44a096","x1","y1","x2","y2","$cc8aedd9079c178d$export$f93b5905241a7cca","$cc8aedd9079c178d$export$e588626963949c9c","$cc8aedd9079c178d$export$7f9972325ebfd559","$cc8aedd9079c178d$export$202e0172ed3c7be0","$cc8aedd9079c178d$export$d141bba7fdc215a3","vec","$cc8aedd9079c178d$export$4a5767248b18ef41","$cc8aedd9079c178d$export$9fd36a9547ed1c6f","arg","Array","isArray","length","$cc8aedd9079c178d$export$9663ddc1cf085b32","vecA","vecB","$cc8aedd9079c178d$export$96ec731ed4dcb222","min","$cc8aedd9079c178d$export$8960430cfd85939f","max","$cc8aedd9079c178d$export$6519c25590136c5e","start","end","delta","steps","$cc8aedd9079c178d$export$89ebf43b06e712ad","pos","i","$cc8aedd9079c178d$export$2a1795c9359f92b9","abs","$8bc8d4e2dec9aa33$export$533b26079ad0b4b","iterable","reducer","initial","acc","idx","$8bc8d4e2dec9aa33$export$45b10814cc054894","from","$8bc8d4e2dec9aa33$export$ddf7c77acd0bf516","iterableA","iterableB","iterA","Symbol","iterator","iterB","value","a","done","doneA","next","b","doneB","$8bc8d4e2dec9aa33$export$8901015135f2fb22","step","undefined","$8bc8d4e2dec9aa33$export$d02631cccf789723","Infinity","$8bc8d4e2dec9aa33$export$de3a4d4a0d731119","predicate","$8bc8d4e2dec9aa33$export$3486a10f30cf1ee4","returnValue","map","fn","f","$8bc8d4e2dec9aa33$export$871de8747c9eaa88","groupsOf","n","group","push","$8bc8d4e2dec9aa33$export$25977399ec389b0e","toArray","first","$8bc8d4e2dec9aa33$export$43128fadae87b74a","last","$8bc8d4e2dec9aa33$export$4c7897fafd92b108","find","$8bc8d4e2dec9aa33$export$71aa6c912b956294","skip","$8bc8d4e2dec9aa33$export$955fc4a6c4be454d","take","$8bc8d4e2dec9aa33$export$b7df5d561049483a","toSet","Set","reduce","forEach","filter","$8bc8d4e2dec9aa33$export$3dea766d36a8935f","count","$8bc8d4e2dec9aa33$export$85b9a36db797e02b","indexed","windowed","buffer","shift","$8bc8d4e2dec9aa33$export$5f2b86065ccf5a1","findIndex","indexOf","$8bc8d4e2dec9aa33$export$305f7d4e9d4624f2","flatMap","$8bc8d4e2dec9aa33$export$5b8affa63fc6df16","skipLast","$8bc8d4e2dec9aa33$export$635f6273df29ea1c","takeEvery","every","skipInitial","$8bc8d4e2dec9aa33$export$4e24be1e1c9d5c69","takeWhile","$8bc8d4e2dec9aa33$export$9384c7afe4015e42","takeUntil","$8bc8d4e2dec9aa33$export$ac8dfd3a7ad06e80","$8bc8d4e2dec9aa33$export$7ecc1a3b11b57dab","updateAt","index","$8bc8d4e2dec9aa33$export$b6d8713d53419d4c","unshift","values","$8bc8d4e2dec9aa33$export$37cdb546b806ae87","skipAfter","$8bc8d4e2dec9aa33$export$f5f1500e16a64c4d","sum","$12ef29e9c8c24503$export$e16d8520af44a096","join","separator","$12ef29e9c8c24503$export$6bb5b649d10f0d08","input","split","$12ef29e9c8c24503$export$65e3907585753458","args","$12ef29e9c8c24503$var$strToType","strVal","type","Number","$cc8aedd9079c178d$exports","parseInt","endsWith","separators","includes","$12ef29e9c8c24503$var$tryGetSeparator","slice","childType","$520099a91db9fbc3$export$8fbd1ac8e83536df","constructor","comparator","this","_heap","_comparator","size","pop","isEmpty","peek","_siftUp","poppedValue","bottom","_swap","_siftDown","replace","replacedValue","_greater","j","node","$520099a91db9fbc3$var$parent","$520099a91db9fbc3$var$left","$520099a91db9fbc3$var$right","maxChild","$e6bef2483974c55d$export$dcc8c5be2e697acf","static","raw","row","set","getNeighbors","hasPos","data","Map","minX","minY","maxX","maxY","needRecalculateBounds","bounds","updateBounds","botRight","topLeft","height","width","_","extendBounds","get","has","mapFn","result","bfs","canGoFromTo","map2d","queue","distance","parent","visited","current","key","add","nextBfs","$e6bef2483974c55d$export$c9e5a085bf83f8b","setGetNeighbors","keys","$e6bef2483974c55d$var$toIterable","to2dArray","topLeftPos","botRightPos","valToString","toString","$e5abbbe7d563ac8a$var$start","$e5abbbe7d563ac8a$export$7f923f14f62d79c","lines","trimEnd","points","line","segment","$e5abbbe7d563ac8a$export$c441dd7fbb1814ca","bot","leftBot","rightBot","drop","startFrom","lb","rb","eq","$8a82902540089ab9$var$canvas","document","getElementById","HTMLCanvasElement","$8a82902540089ab9$var$ctx","getContext","$8a82902540089ab9$var$interval","$8a82902540089ab9$var$inputForm","HTMLFormElement","addEventListener","e","preventDefault","ctx","clearInterval","scale","canvas","scrollIntoView","behavior","colors","o","iter","drawState","map2dStr","cell","fillStyle","fillRect","setInterval","$8a82902540089ab9$var$draw","FormData","trim"],"version":3,"file":"index.ade8cb2f.js.map"}